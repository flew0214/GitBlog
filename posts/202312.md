```python
from IPython.display import Image, display_html

# 定义图像路径
image_path = "img/1204讨论.jpg"

# 定义图像显示大小
image_width = 800  # 设置图像宽度，单位为像素

```


```python
# 20231204
```

#![title](img/1204讨论.jpg)


```python
# 使用HTML标签和CSS样式来控制图像的大小
display_html(f'<img src="{image_path}" width="{image_width}px">', raw=True)
```


<img src="img/1204讨论.jpg" width="800px">



```python
一、AGV生产性算法的明确
    1. 明确效率的计算方法
        1. 广州KPI里的算法
        2. GEEK+协议里的算法
        3. 我的算法
        * 带业务的设备能力/纯设备的设备能力,这两者间的差异，如何去弥补这两者的差距。提出什么改善建议？
        
    2. 不合理的点/哪个更合理
        1. 任务不饱和时，效率怎么算
        2. 单位时间单位设备的计算方法
        * AGV启动到结束的效率稳、任务发布到结束的效率就不稳定了。怎么区分哪些是RMS的调度问题
二、数据的串联
    1. NPS→下发→RMS→取箱→放箱→提货→取箱→放箱
    2. 任务每小时发布量不平衡、任务环境的影响、人员配置的影响
    （人机料法环）
```

自动导引车（AGV）的稼动率通常是指AGV在一段时间内处于工作状态（执行任务）的时间与该段时间总长的比例。精确地计算AGV的稼动率，确实需要对AGV的不同状态进行分类和监测，主要包括以下几种状态：

1. 正在执行任务的时间（工作状态）
2. 空闲等待任务的时间（空闲状态）
3. 正在充电或维护的时间（非工作状态）
4. 故障或停机的时间（故障状态）

稼动率的基本计算方法是：

\[ \text{稼动率} (\%) = \left(\frac{\text{执行任务的时间}}{\text{总时间} - \text{非工作时间}}\right) \times 100 \]

非工作时间通常指因充电、维护或故障导致的停机时间。

为了计算这个比例，你可以通过实时跟踪系统来监控AGV的状态，或者通过日志分析等方式来后期评估这些数据。稳定准确的数据源对于准确计算稼动率至关重要。此外，根据工作场景的不同，可以灵活设置和调整这些分类，并制定相关的数据收集和分析标准。

如果进一步的数据分析表明稼动率低于期望值，可以考虑采用不同的策略来提高稼动率，例如优化任务分配算法，降低空闲和等待时间，或者通过预防性维护减少故障停机时间。

了解您的需求后，如果主要关注AGV在执行任务时对仓库业务的影响，并希望排除非工作时间（如夜间无任务时段），稼动率的计算可以专注于AGV在实际需要执行任务时的表现。这时的稼动率即为“有效稼动率”，其计算可以进行如下调整：

1. 定义有效工作时间：首先明确需要AGV执行任务的业务时间段。
2. 记录执行任务的时间：只统计AGV在有效工作时间内处于工作状态的时间。
3. 排除非有效工作时间：将非工作时间（如半夜无需执行任务的时间）从总时间中排除。

新的有效稼动率计算方法为：

\[ \text{有效稼动率} (\%) = \left(\frac{\text{执行任务的时间}}{\text{有效工作时间}}\right) \times 100 \]

通过这种方式，就可以更精确地评估AGV在高需求时段对仓库业务的实际影响，确保稼动率的计算可以反映业务运营的实际需求。对于非有效工作时间，即使AGV处于空闲状态也不会算作稼动率的分母，这有助于正确评估AGV的业务影响并指导后续的优化决策。


```python
# 1204~1208
1. 完成了AGV数据库17张表的自动备份脚本
    故障表的定义还需要明确，没有定义，光数值是没法利用起来的。
2. 协助小陆 树莓派debian(linux)如何用python调用sqlserver。
   掌握了odbc的方式，编写了相关demo
    最终，使用了FreeTDS,（驱动microsoft-odbc-driver装不上、pymssql也装不上）
```


```python
# 1211
1. BITO的调查
2. WCS DDL保存，并从WCS中拆解出了工作台1~8。并计算效率
```


```python
# 1212
1. 重写了sqlconnet的类：dbcnn。
    1. 采用继承父类的结构
    2. 集成了相关函数到父类中

```


```python
# 1213
1. BP费用修正
   托盘自动化 +80K
   多REC自动化捆包 +70K（20K修缮，50K消耗品）
2. 整理了WCS界面与表间关系
   界面上没有的表并没有继续挖掘，包含master和error相关的表没有解读

```


```python
# 1214
1. 计算了AGV压测数据效率:560.7 箱/H
2. 计算了1127~1209 AGV数据效率: 
    1. 1127~1202:272 箱/H
    2. 1204~1209:345.6 箱/H
    个人观点：
        1. 效率下降的原因不明，但是从订单量的发布情况看。很有可能是任务发布不均衡导致。
        2. AGV平均负载料盒数的差异是否是原因之一？
            1. 能否加长WMS任务发送时间，可以缓解这个问题。

```


```python
# 1215 
```


```python
出差计划（三天）
目的：
    1. 观测物流仓库操作流程、
    2. 自动导引车（AGV）的应用与效率，需要综合考虑设备性能、作业流程、人员操作习惯、仓库管理软件及环境等因素
    
包括观察点和论证方法：
### 第一天：到达与准备
- **上午：**
  - 移动
- **下午：**
  - 了解当前的物流流程、AGV使用情况及已知问题。
  - 实地考察仓库布局，了解整个作业的流程。
  - 观察AGV在实际环境中如何与人员、其他设备交互。
  - 记录数据采集点，为效率分析做准备。

### 第二天：全面观察与数据收集
- **全天：**
  - 集中在实际稼动时间观察AGV的运行效率和流程瓶颈。
  - 使用时间动作研究方法跟踪AGV和工人操作的时间和流程。
  - 进行员工访谈，收集一线员工对AGV使用的感受和建议。
  - 收集关于AGV运行的数据，包括但不限于：
    - 工作循环时间
    - 故障次数与类型
    - 充电周期与续航表现
    - 工作效率及其与人工作业的比较数据
  - 观察物流仓库系统对AGV操作的支持程度。

### 第三天：总结与离开
- **上午：**
  - 根据收集的数据进行初步分析。
  - * 讨论观察到的问题及可能的解决策略。
- **下午：**
  - 移动

### 观察论证方法：
- **效率分析**：通过比较AGV与传统方式的作业时间和资源利用情况来量化效率。
- **问题根源分析**：运用5 Whys或鱼骨图法来深入了解问题出现的根本原因。
- **作业改进建议**：结合观察数据、员工访谈和数理分析来制定可能改善效率的方案。

确保在你的出差期间使用技术工具：比如手持设备记录数据、即时反馈系统、高级计时和采集设备等，以及在会议期间要有积极的互动，鼓励团队成员都参与到讨论中。这样可以确保你的出差既充实又具有成效。
```


```python
12/20(周三).pm:
    一、了解广州当前的作业流程、AGV使用情况及已知问题。(概括性)
    二、实地考察仓库布局，了解整个作业的流程及动线。
    三、观察AGV在实际环境中如何与人员、其他设备交互。

12/20(周四).allday:
    一、效率相关:
        1. 集中在实际稼动时间, 观察AGV的运行效率和流程瓶颈、工人操作的效率和流程
           各业务场景（具体看当天有什么业务）
            1.入库：'上架'
            2.出库：'提货','紧急提货/返库','DEPO 0V', '转送提货'
            3.在库管理：'新料盒上架','盘点', '备库', '移库','商品下架','热点管理'

        2. 观察NPS对AGV系统的衔接和支持程度，人员操作、系统界面等。
        3. 进行员工访谈，收集一线员工对AGV使用的感受和建议。
    二、运维相关(时间充裕有剩余的话就看下，KPI相关的调研):
        1. AGV设备现状运维体制
        2. 观测故障次数与类型、实际的排障处理流程和方法
        3. 观测追溯故障与数据的映射关系
        4. 充电周期与续航表现（AGV工作循环周期）
    
12/21(周五).am:
    一、问题整理和讨论（看情况）
    二、补充观察（前面没观测到的业务场景、故障处理）


```


      Cell In[1], line 1
        12/20(周三).pm：
                    ^
    SyntaxError: invalid character in identifier
    



```python
1. 体制：
    没有明确的流程，主要看时间空余。有时间就做，没时间就延后。
    当遇到某一台车频繁故障就会进行维修保养，（地面也是）
2. 
```


```python

```


```python

```


```python
AGV货架区 料箱的重量计算及监测
1. 是不是实际存储的商品超过了AGV设定的重量阈值（30KG还是40KG来着）
```


```python
import base64
from IPython.display import Image, display

def visualize_flowchart():
    graph = """
    graph LR;
        Start(早上7:30 - 开始) --> 任务单[108个任务组成任务单]
        任务单 --> WMS系统[WMS系统自动下发任务]
        WMS系统 --> AGV系统{AGV系统分配AGV}
        AGV系统 --> 分配AGV[AGV执行任务]
        分配AGV --> 结束(上午8:05 - 结束)
    """
    graphbytes = graph.encode("utf-8")
    base64_bytes = base64.urlsafe_b64encode(graphbytes)
    base64_string = base64_bytes.decode("utf-8")
    
    imageURL = f"https://mermaid.ink/img/{base64_string}"
    display(Image(url=imageURL))

visualize_flowchart()
```


<img src="https://mermaid.ink/img/CiAgICBncmFwaCBMUjsKICAgICAgICBTdGFydCjml6nkuIo3OjMwIC0g5byA5aeLKSAtLT4g5Lu75Yqh5Y2VWzEwOOS4quS7u-WKoee7hOaIkOS7u-WKoeWNlV0KICAgICAgICDku7vliqHljZUgLS0-IFdNU-ezu-e7n1tXTVPns7vnu5_oh6rliqjkuIvlj5Hku7vliqFdCiAgICAgICAgV01T57O757ufIC0tPiBBR1bns7vnu597QUdW57O757uf5YiG6YWNQUdWfQogICAgICAgIEFHVuezu-e7nyAtLT4g5YiG6YWNQUdWW0FHVuaJp-ihjOS7u-WKoV0KICAgICAgICDliIbphY1BR1YgLS0-IOe7k-adnyjkuIrljYg4OjA1IC0g57uT5p2fKQogICAg"/>



```python
import base64
from IPython.display import HTML

def visualize_flowchart():
    graph = """
    gantt
        dateFormat  HH:mm
        axisFormat %H:%M
        title AGV任务分配和完成时间表

        section 任务单
        生成任务单          :done,    des1, 07:30, 10s
        
        section WMS系统
        自动下发任务         :active,  des2, after des1, 60s
        
        section AGV系统
        分配AGV执行任务       :         des3, after des2, 08:00
    """

    url_beginning = "https://mermaid.ink/img/"
    graph_bytes = graph.encode("utf-8")
    base64_bytes = base64.urlsafe_b64encode(graph_bytes)
    base64_string = base64_bytes.decode("utf-8")
    complete_url = f"{url_beginning}{base64_string}"

    return HTML(f'<img src="{complete_url}">')

```


```python
visualize_flowchart()
```




<img src="https://mermaid.ink/img/CiAgICBnYW50dAogICAgICAgIGRhdGVGb3JtYXQgIEhIOm1tCiAgICAgICAgYXhpc0Zvcm1hdCAlSDolTQogICAgICAgIHRpdGxlIEFHVuS7u-WKoeWIhumFjeWSjOWujOaIkOaXtumXtOihqAoKICAgICAgICBzZWN0aW9uIOS7u-WKoeWNlQogICAgICAgIOeUn-aIkOS7u-WKoeWNlSAgICAgICAgICA6ZG9uZSwgICAgZGVzMSwgMDc6MzAsIDEwcwogICAgICAgIAogICAgICAgIHNlY3Rpb24gV01T57O757ufCiAgICAgICAg6Ieq5Yqo5LiL5Y-R5Lu75YqhICAgICAgICAgOmFjdGl2ZSwgIGRlczIsIGFmdGVyIGRlczEsIDYwcwogICAgICAgIAogICAgICAgIHNlY3Rpb24gQUdW57O757ufCiAgICAgICAg5YiG6YWNQUdW5omn6KGM5Lu75YqhICAgICAgIDogICAgICAgICBkZXMzLCBhZnRlciBkZXMyLCAwODowMAogICAg">




```python
def agvtask_flowchart():
    graph = """
    gantt
        dateFormat  HH:mm
        axisFormat %H:%M
        title AGV任务分配和完成时间表

        section 任务单
        生成任务单          :done,    des1, 07:30, 10s
        
        section WMS系统
        自动下发任务         :active,  des2, after des1, 60s
        
        section AGV系统
        分配AGV执行任务      :des3, after des2, 08:00
        
        section 1号AGV
        任务单1-任务1         :task1, after des2, 5m
        任务单1-任务2         :task2, 07:33, 4m
        任务单2-任务3        :task3, after task2, 5m
        
        section 2号AGV
        任务单3-任务4         :task4, after des2, 5m
        任务单3-任务5        :task5, 07:33, 150s
        任务单4-任务6          :task6, after task4, 150s
    """

    url_beginning = "https://mermaid.ink/img/"
    graph_bytes = graph.encode("utf-8")
    base64_bytes = base64.urlsafe_b64encode(graph_bytes)
    base64_string = base64_bytes.decode("utf-8")
    complete_url = f"{url_beginning}{base64_string}"

    return HTML(f'<img src="{complete_url}">')
```


```python
agvtask_flowchart()
```




<img src="https://mermaid.ink/img/CiAgICBnYW50dAogICAgICAgIGRhdGVGb3JtYXQgIEhIOm1tCiAgICAgICAgYXhpc0Zvcm1hdCAlSDolTQogICAgICAgIHRpdGxlIEFHVuS7u-WKoeWIhumFjeWSjOWujOaIkOaXtumXtOihqAoKICAgICAgICBzZWN0aW9uIOS7u-WKoeWNlQogICAgICAgIOeUn-aIkOS7u-WKoeWNlSAgICAgICAgICA6ZG9uZSwgICAgZGVzMSwgMDc6MzAsIDEwcwogICAgICAgIAogICAgICAgIHNlY3Rpb24gV01T57O757ufCiAgICAgICAg6Ieq5Yqo5LiL5Y-R5Lu75YqhICAgICAgICAgOmFjdGl2ZSwgIGRlczIsIGFmdGVyIGRlczEsIDYwcwogICAgICAgIAogICAgICAgIHNlY3Rpb24gQUdW57O757ufCiAgICAgICAg5YiG6YWNQUdW5omn6KGM5Lu75YqhICAgICAgOmRlczMsIGFmdGVyIGRlczIsIDA4OjAwCiAgICAgICAgCiAgICAgICAgc2VjdGlvbiAx5Y-3QUdWCiAgICAgICAg5Lu75Yqh5Y2VMS3ku7vliqExICAgICAgICAgOnRhc2sxLCBhZnRlciBkZXMyLCA1bQogICAgICAgIOS7u-WKoeWNlTEt5Lu75YqhMiAgICAgICAgIDp0YXNrMiwgMDc6MzMsIDRtCiAgICAgICAg5Lu75Yqh5Y2VMi3ku7vliqEzICAgICAgICA6dGFzazMsIGFmdGVyIHRhc2syLCA1bQogICAgICAgIAogICAgICAgIHNlY3Rpb24gMuWPt0FHVgogICAgICAgIOS7u-WKoeWNlTMt5Lu75YqhNCAgICAgICAgIDp0YXNrNCwgYWZ0ZXIgZGVzMiwgNW0KICAgICAgICDku7vliqHljZUzLeS7u-WKoTUgICAgICAgIDp0YXNrNSwgMDc6MzMsIDE1MHMKICAgICAgICDku7vliqHljZU0LeS7u-WKoTYgICAgICAgICAgOnRhc2s2LCBhZnRlciB0YXNrNCwgMTUwcwogICAg">




```python
我有一份AGV的数据。我想从这个数据里统计：每个AGV进出货架时，同时进行的任务。
数据样本是这样的：
	warehouse_job_id	received_time	start_time	done_time	allocated_robot_id
2377	3883904	2023-12-13 22:46:03	2023-12-13 22:46:18	2023-12-13 23:03:26	5331113.000
2395	3883959	2023-12-13 22:47:14	2023-12-13 22:47:48	2023-12-13 22:54:02	5331113.000
2399	3883971	2023-12-13 22:47:34	2023-12-13 22:48:07	2023-12-13 22:53:30	5331113.000
2403	3883983	2023-12-13 22:47:54	2023-12-13 22:50:45	2023-12-13 22:57:37	5331113.000
2561	3884505	2023-12-13 23:06:30	2023-12-13 23:06:42	2023-12-13 23:08:24	5331113.000
2555	3884474	2023-12-13 23:05:59	2023-12-13 23:06:11	2023-12-13 23:16:56	5331112.000
2563	3884522	2023-12-13 23:07:11	2023-12-13 23:07:46	2023-12-13 23:16:02	5331112.000
2565	3884529	2023-12-13 23:07:32	2023-12-13 23:08:05	2023-12-13 23:14:35	5331112.000
2567	3884538	2023-12-13 23:07:52	2023-12-13 23:08:24	2023-12-13 23:14:07	5331112.000
2666	3884876	2023-12-13 23:18:35	2023-12-13 23:18:51	2023-12-13 23:22:45	5331112.000
请帮我做在一个函数里,新建一个字段：agv_task_list
做成类似这样:allocated_robot_id-start_time-done_time
5331113-063013-063318, 5331112-063013-063318
按照同时做的任务的最小starttime和最大donetime
```


      Cell In[65], line 1
        我有一份AGV的数据。我想从这个数据里统计：每个AGV进出货架时，同时进行的任务。
                                                ^
    SyntaxError: invalid character in identifier
    



```python
# 第一版，分错
```


```python
def aggregate_concurrent_tasks(df):
    # 确保时间字段是 datetime 类型
    df['start_time'] = pd.to_datetime(df['start_time'])
    df['done_time'] = pd.to_datetime(df['done_time'])

    # 按照AGV ID和开始时间进行排序
    df = df.sort_values(by=['allocated_robot_id', 'start_time'])

    # 新增一个用来存储AGV任务的列
    df['agv_task_list'] = None

    # 创建一个空列表，用来临时存储同时进行的任务
    concurrent_tasks = []

    for index, row in df.iterrows():
        # 形成当前任务的标识
        current_task = f"{int(row['allocated_robot_id'])}-{row['start_time'].strftime('%H%M%S')}-{row['done_time'].strftime('%H%M%S')}"
        
        # 如果列表为空，或者当前任务与列表中任务不重叠，则开始一个新任务列表
        if not concurrent_tasks or row['start_time'] > concurrent_tasks[-1]['end']:
            if concurrent_tasks:
                # 将当前任务列表中的最小开始时间和最大结束时间写入DF的上一行
                last_start = min(task['start'] for task in concurrent_tasks)
                last_end = max(task['end'] for task in concurrent_tasks)
                last_robot = concurrent_tasks[0]['robot']
                last_task_string = f"{last_robot}-{last_start.strftime('%H%M%S')}-{last_end.strftime('%H%M%S')}"
                
                # 更新上一个任务列表的所有任务的 'agv_task_list'
                for task in concurrent_tasks:
                    df.at[task['index'], 'agv_task_list'] = last_task_string
                    
            # 重置任务列表
            concurrent_tasks = [{'start': row['start_time'], 'end': row['done_time'], 'robot': int(row['allocated_robot_id']), 'index': index, 'task': current_task}]
        else:
            # 当前任务与列表中的任务重叠，加入并更新任务列表
            concurrent_tasks.append({'start': row['start_time'], 'end': row['done_time'], 'robot': int(row['allocated_robot_id']), 'index': index, 'task': current_task})

    # 别忘了更新列表中的最后一个任务
    if concurrent_tasks:
        last_start = min(task['start'] for task in concurrent_tasks)
        last_end = max(task['end'] for task in concurrent_tasks)
        last_robot = concurrent_tasks[0]['robot']
        last_task_string = f"{last_robot}-{last_start.strftime('%H%M%S')}-{last_end.strftime('%H%M%S')}"
        
        # 更新最后一个任务的 'agv_task_list'
        for task in concurrent_tasks:
            df.at[task['index'], 'agv_task_list'] = last_task_string

    return df
```


```python
# 第二版，AGVID 会分错
```


```python
# 构建一个新的函数来精确的判断AGV的同时进行的任务
def aggregate_concurrent_tasks(df):
    # 首先将时间字符串转换为datetime
    df['start_time'] = pd.to_datetime(df['start_time'])
    df['done_time'] = pd.to_datetime(df['done_time'])

    # 新建一个空的字典，用来追踪AGV的任务
    tasks_by_robot = {}

    # 新建一个空的列用于存放处理后的agv_task_list
    df['agv_task_list'] = pd.Series(dtype='object')

    # 对DataFrame进行排序以保持时间顺序
    df.sort_values(by=['allocated_robot_id', 'start_time'], inplace=True)

    # 遍历DataFrame的每一行
    for index, row in df.iterrows():
        robot_id = row['allocated_robot_id']
        start_time = row['start_time']
        end_time = row['done_time']
        concurrent_task = f"{int(robot_id)}-{start_time.strftime('%H%M%S')}-{end_time.strftime('%H%M%S')}"

        if robot_id not in tasks_by_robot:
            tasks_by_robot[robot_id] = []

        # 检查当前任务是否与之前任一任务重叠
        updated = False
        for task in tasks_by_robot[robot_id]:
            if not(start_time > task['done_time'] or end_time < task['start_time']):
                task['start_time'] = min(task['start_time'], start_time)
                task['done_time'] = max(task['done_time'], end_time)
                task['task_ids'].append(index)
                updated = True
                break
        
        # 如果此任务与现有任务不重叠，则为其创建一个新任务单
        if not updated:
            tasks_by_robot[robot_id].append({
                'start_time': start_time,
                'done_time': end_time,
                'task_ids': [index]
            })

    # 将结果写回DataFrame
    for robot_task_list in tasks_by_robot.values():
        for task in robot_task_list:
            concurrent_task_str = f"{int(robot_id)}-{task['start_time'].strftime('%H%M%S')}-{task['done_time'].strftime('%H%M%S')}"
            for task_id in task['task_ids']:
                df.at[task_id, 'agv_task_list'] = concurrent_task_str

    return df
```


```python
# 第三版 优化版
```


```python
def aggregate_concurrent_tasks(df):
    # 首先将时间字符串转换为datetime
    df['start_time'] = pd.to_datetime(df['start_time'])
    df['done_time'] = pd.to_datetime(df['done_time'])

    # 新建一个空的字典，用来追踪AGV的任务
    tasks_by_robot = {}

    # 对DataFrame进行排序以保持时间顺序
    df.sort_values(by=['allocated_robot_id', 'start_time'], inplace=True)

    # 获取唯一的机器人ID列表
    unique_robot_ids = df['allocated_robot_id'].unique()
    
    # 初始化任务字典
    for robot_id in unique_robot_ids:
        tasks_by_robot[robot_id] = []

    # 遍历DataFrame的每一行
    for index, row in df.iterrows():
        robot_id = row['allocated_robot_id']
        start_time = row['start_time']
        end_time = row['done_time']
        
        # 检查当前任务是否与之前任一任务重叠
        updated = False
        for task in tasks_by_robot[robot_id]:
            if not (start_time > task['done_time'] or end_time < task['start_time']):
                # 如果时间重叠
                task['start_time'] = min(task['start_time'], start_time)
                task['done_time'] = max(task['done_time'], end_time)
                task['task_ids'].append(index)
                updated = True
                break
        
        if not updated:
            # 如果此任务与现有任务不重叠，则添加新任务
            tasks_by_robot[robot_id].append({
                'start_time': start_time,
                'done_time': end_time,
                'task_ids': [index]
            })

    # 为每个任务创建agv_task_list条目
    for robot_id, tasks in tasks_by_robot.items():
        for task in tasks:
            concurrent_task_str = f"{int(robot_id)}-{task['start_time'].strftime('%H%M%S')}-{task['done_time'].strftime('%H%M%S')}"
            for task_id in task['task_ids']:
                df.at[task_id, 'agv_task_list'] = concurrent_task_str

    return df
```


```python
老师，flew0214又来求教了。我想画出一张甘特图。原因是我发现AGV在作业时，取箱任务（从库位货架到临时货架），还箱任务（从临时货架到库位货架）是有重叠的。

为了说明这张图，我抽出了一份数据，按照一辆AGV的数据，因为一辆AGV只有8个库位存储。数据上超过了8个。比较异常，发现了这个情况。
```


```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import matplotlib.dates as mdates

# Step 2: Create the data for the Gantt chart
tasks = ['Task 1', 'Task 2', 'Task 3', 'Task 4']
start_dates = ['2023-06-01', '2023-06-03', '2023-06-06', '2023-06-09']
durations = [2, 4, 2, 5]

# Step 3: Initialize the figure and axis
fig, ax = plt.subplots()

# Step 4: Set y-axis tick labels
ax.set_yticks(np.arange(len(tasks)))
ax.set_yticklabels(tasks)

# Step 5: Plot each task as a horizontal bar
for i in range(len(tasks)):
    start_date = pd.to_datetime(start_dates[i])
    end_date = start_date + pd.DateOffset(days=durations[i])
    ax.barh(i, end_date - start_date, left=start_date, height=0.5, align='center')

# Step 6: Set x-axis limits
min_date = pd.to_datetime(min(start_dates))
max_date = pd.to_datetime(max(start_dates)) + pd.DateOffset(days=max(durations))
ax.set_xlim(min_date, max_date)

# Step 7: Customize the chart
ax.xaxis_date()
ax.xaxis.set_major_locator(mdates.WeekdayLocator())
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
ax.set_xlabel('Date')
ax.set_ylabel('Tasks')
ax.set_title('Basic Gantt Chart')

# Step 8: Display the chart
plt.grid(True)
plt.show()

```


    
![png](output_32_0.png)
    



```python
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt

plt.rcParams['font.sans-serif']=['Microsoft YaHei']

# Corrected data with quoted date strings
data = np.array([
    ['2021-6-1', '2021-7-15', '第一阶段'],
    ['2021-7-16', '2021-9-15', '第二阶段'],
    ['2021-9-16', '2021-9-30', '第三阶段']
])

x = []
w = []
for d in data[::-1]:
    d1 = dt.datetime.strptime(d[0], '%Y-%m-%d')
    d2 = dt.datetime.strptime(d[1], '%Y-%m-%d')
    x.append(d1)  
    w.append((d2 - d1).days + 1)

y = data[::-1, 2]

data2 = np.array([
    ['2021-6-1', '2021-7-15', '第一阶段'],
    ['2021-7-16', '2021-8-15', '第二阶段']
])

x2 = []
w2 = []
for d in data2[::-1]:
    d1 = dt.datetime.strptime(d[0], '%Y-%m-%d')
    d2 = dt.datetime.strptime(d[1], '%Y-%m-%d')
    x2.append(d1)
    w2.append((d2 - d1).days + 1)

y2 = data2[::-1, 2]

plt.figure(figsize=(8, 2))
plt.grid()

plt.barh(y, w, height=1, left=x, label='计划进度')
plt.barh(y2, w2, height=0.8, left=x2, label='完成进度')
plt.legend()

# Set x-ticks
x.append(dt.datetime.strptime(data[-1, 1], '%Y-%m-%d'))
xticks = [d[0] for d in data[::-1]]
xticks.insert(0, data[-1, 1])

# Convert string dates to datetime objects
xticks = [dt.datetime.strptime(date, '%Y-%m-%d') for date in xticks]
plt.xticks(xticks, [date.strftime('%Y-%m-%d') for date in xticks])

plt.ylabel('项目阶段')
plt.title('项目进度')
plt.show()
```


    
![png](output_33_0.png)
    



```python
import matplotlib.pyplot as plt
import pandas as pd
import matplotlib.dates as mdates

# Step 1: Define the data
data = {
    'warehouse_job_id': [3870697, 3873098, 3873157, 3876747, 3876768, 3876795],
    'start_time': ['2023-12-13 20:45:53', '2023-12-13 20:46:17', '2023-12-13 20:48:32',
                   '2023-12-13 20:50:50', '2023-12-13 20:51:31', '2023-12-13 20:51:50'],
    'done_time': ['2023-12-13 20:50:16', '2023-12-13 20:50:49', '2023-12-13 20:51:30',
                  '2023-12-13 20:54:30', '2023-12-13 20:58:05', '2023-12-13 20:57:16'],
    'direct_type': [2, 2, 2, 1, 1, 1]
}

# Step 2: Create a DataFrame from the data
df = pd.DataFrame(data)

# Convert start and done times to datetime
df['start_time'] = pd.to_datetime(df['start_time'])
df['done_time'] = pd.to_datetime(df['done_time'])

# Calculate the duration for the x-axis length
df['duration'] = df['done_time'] - df['start_time']

# Step 3: Initialize the figure and axis
fig, ax = plt.subplots(figsize=(10, 6))

# Step 4: Plot each task as a horizontal bar
for i, row in df.iterrows():
    ax.barh(i, row['duration'], left=row['start_time'], height=0.4, align='center', color='skyblue')

# Step 5: Set y-axis tick labels to the warehouse_job_id
ax.set_yticks(range(len(df)))
ax.set_yticklabels(df['warehouse_job_id'])

# Step 6: Set x-axis limits and format the dates on the x-axis
ax.xaxis_date()
ax.xaxis.set_major_locator(mdates.HourLocator(interval=1))  # Use an appropriate interval for the hour locator
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M'))

# Customize the chart
ax.set_xlabel('Time')
ax.set_ylabel('Warehouse Job ID')
ax.set_title('Warehouse Job Gantt Chart')
ax.grid(True)

# Rotate x-axis labels to avoid overlapping
plt.xticks(rotation=45)

# Step 7: Display the chart
plt.tight_layout()  # Adjust layout to fit everything.
plt.show()
```


    
![png](output_34_0.png)
    



```python
# Convert start and done times to datetime
df['start_time'] = pd.to_datetime(df['start_time'])
df['done_time'] = pd.to_datetime(df['done_time'])

# Calculate the duration for each task
df['duration'] = df['done_time'] - df['start_time']
```


```python
import matplotlib.pyplot as plt
import pandas as pd
import matplotlib.dates as mdates

# Step 1: Define the data
data = {
    'warehouse_job_id': [3870697, 3873098, 3873157, 3876747, 3876768, 3876795],
    'start_time': ['2023-12-13 20:45:53', '2023-12-13 20:46:17', '2023-12-13 20:48:32',
                   '2023-12-13 20:50:50', '2023-12-13 20:51:31', '2023-12-13 20:51:50'],
    'done_time': ['2023-12-13 20:50:16', '2023-12-13 20:50:49', '2023-12-13 20:51:30',
                  '2023-12-13 20:54:30', '2023-12-13 20:58:05', '2023-12-13 20:57:16'],
    'direct_type': [2, 2, 2, 1, 1, 1]
}

# Step 2: Create a DataFrame from the data
df = pd.DataFrame(data)

# Convert start and done times to datetime
df['start_time'] = pd.to_datetime(df['start_time'])
df['done_time'] = pd.to_datetime(df['done_time'])

# Calculate the duration for each task
df['duration'] = df['done_time'] - df['start_time']

# Step 3: Initialize the figure and axis
fig, ax = plt.subplots(figsize=(10, 6))

# Step 4: Set color mapping for different types
colors = {1: 'skyblue', 2: 'lightgreen'}

# Step 5: Plot each task as a horizontal bar with color based on type
for i, row in df.iterrows():
    color = colors[row['direct_type']]
    ax.barh(i, row['duration'], left=row['start_time'], height=0.4, align='center', color=color)

# Step 6: Set y-axis tick labels to the warehouse_job_id
ax.set_yticks(range(len(df)))
ax.set_yticklabels(df['warehouse_job_id'])

# Step 7: Extend x-axis to 21 hours from the minimum start_time and set format
min_start_time = df['start_time'].min()
ax.set_xlim(min_start_time, min_start_time + pd.DateOffset(hours=0.5))
ax.xaxis_date()
ax.xaxis.set_major_locator(mdates.HourLocator(interval=1))  # Using 1-hour intervals
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M'))

# Customize the chart
ax.set_xlabel('Time')
ax.set_ylabel('Warehouse Job ID')
ax.set_title('Warehouse Job Gantt Chart by Type')
ax.grid(True)

# Rotate and align x-axis labels to avoid overlapping
plt.setp(ax.get_xticklabels(), rotation=45, ha="right")

# Step 8: Display the chart
plt.tight_layout()  # Adjust layout to fit everything
plt.show()
```


    
![png](output_36_0.png)
    



```python
import matplotlib.pyplot as plt
import pandas as pd
import matplotlib.dates as mdates

# Step 1: Define the data
data = {
    'warehouse_job_id': [3870697, 3873098, 3873157, 3876747, 3876768, 3876795],
    'start_time': ['2023-12-13 20:45:53', '2023-12-13 20:46:17', '2023-12-13 20:48:32',
                   '2023-12-13 20:50:50', '2023-12-13 20:51:31', '2023-12-13 20:51:50'],
    'done_time': ['2023-12-13 20:50:16', '2023-12-13 20:50:49', '2023-12-13 20:51:30',
                  '2023-12-13 20:54:30', '2023-12-13 20:58:05', '2023-12-13 20:57:16'],
    'direct_type': [2, 2, 2, 1, 1, 1]
}

# Step 2: Create a DataFrame from the data
df = pd.DataFrame(data)

# Convert start and done times to datetime
df['start_time'] = pd.to_datetime(df['start_time'])
df['done_time'] = pd.to_datetime(df['done_time'])

# Calculate the duration for each task
df['duration'] = df['done_time'] - df['start_time']

# Step 3: Initialize the figure and axis
fig, ax = plt.subplots(figsize=(10, 6))

# Step 4: Set color mapping for different types
colors = {1: 'skyblue', 2: 'lightgreen'}

# Step 5: Plot each task as a horizontal bar with color based on type
for i, row in df.iterrows():
    color = colors[row['direct_type']]
    ax.barh(i, row['duration'], left=row['start_time'], height=0.4, align='center', color=color)

# Step 6: Set y-axis tick labels to the warehouse_job_id
ax.set_yticks(range(len(df)))
ax.set_yticklabels(df['warehouse_job_id'])

# Step 7: Extend x-axis to 21 hours from the minimum start_time and set format
min_start_time = df['start_time'].min()
ax.set_xlim(min_start_time, min_start_time + pd.DateOffset(hours=0.5))
ax.xaxis_date()
ax.xaxis.set_major_locator(mdates.HourLocator(interval=1))  # Using 1-hour intervals
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M'))

# Customize the chart
ax.set_xlabel('Time')
ax.set_ylabel('Warehouse Job ID')
ax.set_title('Warehouse Job Gantt Chart by Type')
ax.grid(True)

# Rotate and align x-axis labels to avoid overlapping
plt.setp(ax.get_xticklabels(), rotation=45, ha="right")

# Step 8: Display the chart
plt.tight_layout()  # Adjust layout to fit everything
plt.show()
```


    
![png](output_37_0.png)
    



```python
def plot_gantt(df):
    # Initialize the figure and axis
    fig, ax = plt.subplots(figsize=(10, 6))

    # Set color mapping for different types
    colors = {1: 'skyblue', 2: 'lightgreen'}

    # Plot each task as a horizontal bar with color based on type
    for i, row in df.iterrows():
        color = colors[row['direct_type']]
        ax.barh(i, row['duration'], left=row['start_time'], height=0.4, align='center', color=color)

    # Set y-axis tick labels to the warehouse_job_id
    ax.set_yticks(range(len(df)))
    ax.set_yticklabels(df['warehouse_job_id'])

    # Set up the x-axis format
    min_start_time = df['start_time'].min()
    ax.set_xlim(min_start_time, min_start_time + pd.DateOffset(hours=0.5))
    ax.xaxis_date()
    ax.xaxis.set_major_locator(mdates.MinuteLocator(byminute=range(0, 60, 1)))  # 5-minute intervals
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))

    # Customize the chart
    ax.set_xlabel('Time')
    ax.set_ylabel('Warehouse Job ID')
    ax.set_title('Warehouse Job Gantt Chart by Type')
    ax.grid(True)

    # Rotate and align x-axis labels
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right")

    # Display the chart
    plt.tight_layout()
    plt.show()

# Example usage:
# Assuming df is your DataFrame with the appropriate columns: 'warehouse_job_id', 'start_time', 'done_time', 'direct_type'
# and 'duration' where 'start_time' and 'done_time' are already converted to pandas datetime objects
# and 'duration' is calculated as the timedelta between 'done_time' and 'start_time'.
```


```python
# Ensure your df has the required format
plot_gantt(df)
```


    
![png](output_39_0.png)
    



```python
df.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>warehouse_job_id</th>
      <th>start_time</th>
      <th>done_time</th>
      <th>direct_type</th>
      <th>duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3870697</td>
      <td>2023-12-13 20:45:53</td>
      <td>2023-12-13 20:50:16</td>
      <td>2</td>
      <td>0 days 00:04:23</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3873098</td>
      <td>2023-12-13 20:46:17</td>
      <td>2023-12-13 20:50:49</td>
      <td>2</td>
      <td>0 days 00:04:32</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3873157</td>
      <td>2023-12-13 20:48:32</td>
      <td>2023-12-13 20:51:30</td>
      <td>2</td>
      <td>0 days 00:02:58</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3876747</td>
      <td>2023-12-13 20:50:50</td>
      <td>2023-12-13 20:54:30</td>
      <td>1</td>
      <td>0 days 00:03:40</td>
    </tr>
    <tr>
      <th>4</th>
      <td>3876768</td>
      <td>2023-12-13 20:51:31</td>
      <td>2023-12-13 20:58:05</td>
      <td>1</td>
      <td>0 days 00:06:34</td>
    </tr>
  </tbody>
</table>
</div>




```python
df.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 6 entries, 0 to 5
    Data columns (total 5 columns):
     #   Column            Non-Null Count  Dtype          
    ---  ------            --------------  -----          
     0   warehouse_job_id  6 non-null      int64          
     1   start_time        6 non-null      datetime64[ns] 
     2   done_time         6 non-null      datetime64[ns] 
     3   direct_type       6 non-null      int64          
     4   duration          6 non-null      timedelta64[ns]
    dtypes: datetime64[ns](2), int64(2), timedelta64[ns](1)
    memory usage: 368.0 bytes
    


```python
import matplotlib.pyplot as plt 
  
  
# Adding title to the plot 
plt.title('GEEKSFORGEEKS - EXAMPLE') 
  
# adding x axis label to the plot 
plt.xlabel('Number of Cars') 
  
# label for y axis  for the plot 
plt.ylabel('Average Speed') 
  
x_1 = [(10, 3), (15, 4)] 
y_1 = (50, 10) 
  
# Plotting the chart 
plt.broken_barh(x_1, y_1, facecolors ='cyan') 
  
x_2 = [(1, 4), (10, 1), (15, 4), (25, 6)] 
y_2 = (70, 10) 
  
# Plotting the chart 
plt.broken_barh(x_2, y_2, facecolors ='green') 
  
x_3 = [(5, 3), (11, 2), (18, 5)] 
y_3 = (90, 10) 
  
# Plotting the chart 
plt.broken_barh(x_3, y_3, facecolors ='blue') 
  
plt.show()
```


    
![png](output_42_0.png)
    



```python
import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.broken_barh([(110, 30), (150, 10)], (10, 9), facecolors='tab:blue')
ax.broken_barh([(10, 50), (100, 20), (130, 10)], (20, 9),
               facecolors=('tab:orange', 'tab:green', 'tab:red'))
ax.set_ylim(5, 35)
ax.set_xlim(0, 200)
ax.set_xlabel('seconds since start')
ax.set_yticks([15, 25])
ax.set_yticklabels(['Bill', 'Jim'])
ax.grid(True)
ax.annotate('race interrupted', (61, 25),
            xytext=(0.8, 0.9), textcoords='axes fraction',
            arrowprops=dict(facecolor='black', shrink=0.05),
            fontsize=16,
            horizontalalignment='right', verticalalignment='top')

plt.show()
```


    
![png](output_43_0.png)
    



```python
# 接下来的action
 1. 下周一例会的课题对应
 2. 广州出差的成果物
 3. 广州AGV的效率测算等指标
 4. 数据库备份体制的结构示意图
 5. 压测数据和真实数据的比较模型
```


```python
在设备管理领域，"TPS"的全称可能是指“Total Productive Maintenance”，即“全面生产性维护”。
这是一种以提升设备和工厂生产效率为目标的精益生产理念。全面生产性维护主张将预防维护、生产维护和改善维护整合为一个系统，力求消除设备故障、减少生产中断和提高生产可靠性。

请注意，TPS 也广为人知地代表了 “Toyota Production System”，即“丰田生产方式”，这是一种集中于持续改进和消除浪费的综合性生产管理系统。
虽然这个系统更多的是关注生产和供应链管理的全面优化，但其实也包括了对设备管理等方面的考量。

因此，当TPS用于设备管理时，通常会是指“Total Productive Maintenance”。
```


```python
在设备管理中，特别是关注于设备状态、保养和运维的场景，“TBMS”可能指的是“Total Building Management System”。
这样的系统涵盖了建筑物和设施中所有机械和电气设备的监控与管理，确保系统整体的高效运行。这通常包含能源管理、设备维保、安全系统和其他与建筑物运营相关的子系统。

不过，要注意，“TBMS”这个缩写并不是一个普遍认可的标准术语，不同的组织和行业可能会赋予它不同的含义。
因此，如果在特定文档、报告或讨论中遇到“TBMS”这样的缩写，最好查明其具体含义，或者询问使用该缩写的人以获取正确的全称。
```


```python
实时看板（Real-time Kanban）通常指的是可以即时更新和反映工作进度的管理工具。
它能够实时显示任务的当前状态，比如在软件开发中，某个功能正在开发、测试或已经完成。
实时看板的关键在于能够动态追踪任务或项目进度，团队成员可以立即看到每个任务最新的更新，便于及时调整工作安排。

即时看板（Just-in-time Kanban）则强调的是按需制作，在生产和库存管理中，即时看板旨在减少库存和过度生产。
它基于即时制造原则，即只有在需求出现时才开始生产流程，从而节约资源和成本。
即时看板侧重于优化整个供应链和生产流程，确保物料和产品能够“恰好在需要的时间到达需要的地点”。
```


```python

```


```python
import pandas as pd
```


```python
# 定义要写入的数据
data = '''	现状	SCADA	BITO	自主开发
实时看板（状态）	各设备系统查看	改修报价中	需要对接接口	"1.需要对接接口(WMS\WCS\SCADA\AGV\分拨墙\滚筒线）
2.数据库+web框架部署、实时看板开发"
历史数据分析及报表功能		"开放数据库
报表另收费"	有	"1. 建立自动备份机制（本地文件存储 or 数据库db)
2. 报表：没系统用python、有系统看系统使用框架决定"
SCADA对象外的设备监控		不含	不含	"1.对象外设备包含：叉车、上架车、提火车、电池等。
2. 监控范围：温度、定位、"
设备维护保养系统化管理	手工	不含	不确定	保养周期提醒，故障记录，维护日志，备件管理等'''
```


```python
data = '''
功能	现状	SCADA	BITO	自主开发	费用	周期	优势	风险
实时看板（状态）	各设备系统查看	改修报价中	需要对接接口	"1.需要对接接口(WMS\WCS\SCADA\AGV\分拨墙\滚筒线）
2.数据库+web框架部署、实时看板开发"				
历史数据分析及报表功能		"开放数据库
报表另收费"	有	"1. 建立自动备份机制（本地文件存储 or 数据库db)
2. 报表：没系统用python、有系统看系统使用框架决定"			"功能全面灵活、
可以定制化满足特定需求"	"技术实现复杂性高、
开发周期长、
数据维护和
升级成本"
SCADA对象外的设备监控		不含	不含	"1.对象外设备包含：叉车、上架车、提火车、电池等。
2. 监控范围：温度、定位、"				兼容性和扩展性问题
设备维护保养系统化管理	手工	不含	不确定	保养周期提醒，故障记录，维护日志，备件管理等			提高设备的使用效率和降低故障率。	初始投入成本和后续的系统升级。

'''

```


```python
data_io = pd.io.common.StringIO(data)
df = pd.read_csv(data_io, sep="\t")
```


```python
data='''
实时看板（状态） 各设备系统查看 改修报价中 需要对接接口 自定义系统框架，灵活的用户界面设计 自定义定价 长期 完全定制化选项，适应性强 长开发周期，维护成本高 实时数据可视化，提高响应速度 依赖现成产品的限制 制表符分隔 记号
历史数据分析及报表功能 开放数据库报表另收费 有 数据模型构建，支持各类报表生成 自定义定价 中到长期 功能全面, 灵活定制 技术实现复杂, 数据维护/升级成本 成熟方案，稳定性高 可能的限制性修改 数据分析深入，报告自定义 报表功能限制
SCADA对象外的设备监控 不含 不含 设备多样性监控，温度和定位信息 自定义定价 中期 精确的监控范围，兼容新设备 兼容性和扩展性问题 已有设备集成 设备类型限制 未知
设备维护保养系统化管理 手工 不含 系统工作流程优化，包括定期提醒和维护记录 自定义定价 长期 有效性和降低故障率 初始投入成本和升级维护 已有流程支持 未知 设备保养简化 未知
'''
```


```python
data_io = pd.io.common.StringIO(data)
df2 = pd.read_csv(data_io, sep=" ")
```


```python
df2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>实时看板（状态）</th>
      <th>各设备系统查看</th>
      <th>改修报价中</th>
      <th>需要对接接口</th>
      <th>自定义系统框架，灵活的用户界面设计</th>
      <th>自定义定价</th>
      <th>长期</th>
      <th>完全定制化选项，适应性强</th>
      <th>长开发周期，维护成本高</th>
      <th>实时数据可视化，提高响应速度</th>
      <th>依赖现成产品的限制</th>
      <th>制表符分隔</th>
      <th>记号</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>历史数据分析及报表功能</th>
      <td>开放数据库报表另收费</td>
      <td>有</td>
      <td>数据模型构建，支持各类报表生成</td>
      <td>自定义定价</td>
      <td>中到长期</td>
      <td>功能全面,</td>
      <td>灵活定制</td>
      <td>技术实现复杂,</td>
      <td>数据维护/升级成本</td>
      <td>成熟方案，稳定性高</td>
      <td>可能的限制性修改</td>
      <td>数据分析深入，报告自定义</td>
      <td>报表功能限制</td>
    </tr>
    <tr>
      <th>SCADA对象外的设备监控</th>
      <td>不含</td>
      <td>不含</td>
      <td>设备多样性监控，温度和定位信息</td>
      <td>自定义定价</td>
      <td>中期</td>
      <td>精确的监控范围，兼容新设备</td>
      <td>兼容性和扩展性问题</td>
      <td>已有设备集成</td>
      <td>设备类型限制</td>
      <td>未知</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>设备维护保养系统化管理</th>
      <td>手工</td>
      <td>不含</td>
      <td>系统工作流程优化，包括定期提醒和维护记录</td>
      <td>自定义定价</td>
      <td>长期</td>
      <td>有效性和降低故障率</td>
      <td>初始投入成本和升级维护</td>
      <td>已有流程支持</td>
      <td>未知</td>
      <td>设备保养简化</td>
      <td>未知</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
print(df['自主开发'][0])
```

    1.需要对接接口(WMS\WCS\SCADA\AGV\分拨墙\滚筒线）
    2.数据库+web框架部署、实时看板开发
    


```python
# 字段提取数字 ，不能单独处理数字列
```


```python
import pandas as pd

# 示例数据
data = {
    'WEIGHT': ['123kg', '体重200克', '大约 2.5 吨', '未知','132',123]
}

# 转换成DataFrame
df = pd.DataFrame(data)

# 使用正则表达式提取数字，假设数字是整数或浮点数，并将结果转换为float类型
df['WEIGHT_NUMERIC'] = df['WEIGHT'].str.extract(r'(\d+\.?\d*)').astype(float)

# 现在 df['WEIGHT_NUMERIC'] 包含提取的数字（如果存在），可以用于比较
print(df)
```

         WEIGHT  WEIGHT_NUMERIC
    0     123kg           123.0
    1    体重200克           200.0
    2  大约 2.5 吨             2.5
    3        未知             NaN
    4       132           132.0
    5       123             NaN
    


```python
# 更新版本，能处理各种类型
```


```python
import pandas as pd

# 示例数据
data = {
    'WEIGHT': ['123kg', 200, '大约 2.5 吨', '未知', 300, None, '456.78']
}

# 创建DataFrame
df = pd.DataFrame(data)

# 将所有非字符串值转换为字符串，然后提取数字部分
df['WEIGHT_NUMERIC'] = df['WEIGHT'].astype(str).str.extract(r'(\d+\.?\d*)')

# 把提取出来的数字字符串转换为float类型
df['WEIGHT_NUMERIC'] = pd.to_numeric(df['WEIGHT_NUMERIC'], errors='coerce')

# 输出结果
print(df['WEIGHT_NUMERIC'])
```

    0    123.00
    1    200.00
    2      2.50
    3       NaN
    4    300.00
    5       NaN
    6    456.78
    Name: WEIGHT_NUMERIC, dtype: float64
    


```python
电焊条亮度、烟花仙女棒亮度的比较
```

电焊条和烟花仙女棒发出的亮度非常不同，主要是由于它们的应用和燃烧温度差异造成的。

电焊条是用于电弧焊接的，其亮度非常高，足以导致未保护眼睛的人眼睛损伤（焊接弧光眼），因为它产生的光辐射很强，包括紫外线和可见光。电焊弧的温度可以达到约 6500°F (3600°C) 或更高，这个温度几乎与太阳表面的温度相当。

相比之下，烟花仙女棒是一种低危险性的烟火产品，主要用于娱乐，尤其是由儿童在户外使用。它发光的原理是通过燃烧金属粉末产生火花，通常是铁或铝粉末。烟花仙女棒的亮度较低，温度也远低于电弧焊，通常在1000°F到3000°F (538°C到1649°C)之间。因此，烟花仙女棒的光亮程度远低于电焊条，对眼睛的损伤风险也相对较小。不过，即使是烟花仙女棒，也推荐在成人监护下使用，以避免烧伤等意外。

需要注意的是，不论是电焊条还是烟花仙女棒，在使用时都应该采取适当的安全措施来保护自己和周围的人。

亮度是光学术语，指的是给定表面上单位面积上光的强度，单位为勒克斯（lx）或照度，也可以使用坎德拉/平方米（cd/m²），后者是表亮度的单位。但这些度量通常不用来测量电焊条或烟花仙女棒的亮度。

电焊弧亮度非常高，可以达到数万到百万勒克斯；由于这种亮度甚至可能会导致瞬时的视力损失（弧光眼），因此必须使用特制的防护眼镜或面罩来观察电焊工作。另一方面，烟花仙女棒亮度相对较低，一般不足以引起视力损害，通常在几百到几千勒克斯。

请注意，以上数值仅为粗略估计，具体亮度会受到多种因素的影响，包括但不限于环境光线条件、观察距离、材料类型等。想要得到精确的测量数值，需要使用光度计等专业设备在受控环境下进行。此外，除了亮度外，电焊弧还会产生大量的紫外线和红外线辐射，这些都是用普通亮度测量方法无法完全描述的。


```python
写一篇800字的“我的青春有温暖”
```


```python
親愛的日記，

今天是一個特別的日子，我要開始寫下我青春的故事。我的青春有温暖，充滿著美好的回憶和成長的點滴。我希望這段青春的故事能夠成為我未來的寶貴財富。

1. [我年少時的夢想是什麼？]我還記得那個年少時的自己，滿懷著對世界的好奇和渴望，夢想著成為一名藝術家。我喜歡用畫筆表達自己的情感，每一次揮灑都讓我感到自由和快樂。我花了很多時間在繪畫上，不僅是為了追求技巧的提升，更是為了找到我內心深處真正想要表達的東西。

2. [我在成長過程中遇到的困難是什麼？]然而，隨著時間的推移，我開始面臨一些困難。有一段時間，我對自己的能力產生了懷疑。我的作品被人批評，我感到很受傷，甚至有些灰心。但是，我並沒有放棄，我告訴自己要堅持下去，相信自己的才華。

3. [我是如何克服困難的？]我開始主動尋找藝術家的靈感和知識。我閱讀藝術家的傳記，觀看他們的作品，並參加一些藝術展覽和工作坊。透過這些經驗，我不僅學到了更多的藝術技巧，也找到了自己的風格和獨特性。這樣的努力和堅持讓我重新燃起了對藝術的熱情。

4. [我如何在青春中尋找溫暖？]除了藝術，我還在青春中尋找到了其他溫暖的事物。我愛與家人一起度過的時光，那是我們相互關懷和支持的寶貴時刻。我也喜歡與朋友們一起分享歡笑和眼淚，彼此鼓勵和成長。此外，我還熱愛大自然，喜歡在公園散步、欣賞花朵和感受陽光的溫暖。

5. [我在青春中的成長和收獲是什麼？]這段青春的旅程中，我不僅在藝術上取得了一定的成就，也在內心深處變得更加堅強和自信。我學會了面對困難和挑戰，並從中獲得成長和收獲。我明白了「失敗是成功之母」的道理，並學會了從錯誤中吸取教訓，不斷進步。

6. [我對未來的展望是什麼？]未來，我希望能夠將我的藝術熱情和才華發揮到更大的程度。我想要將我的作品展示給更多的人，讓他們感受到我的創作的溫暖和力量。我希望能夠與其他藝術家交流和合作，不斷挑戰自己，探索更多的可能性。同時，我也希望能夠在生活中保持對家人和朋友的關愛和溫暖，與他們一起創造更多美好的回憶。

這個青春，雖然有困難和挑戰，但我相信我所經歷的每一個瞬間都是值得的。它們塑造了我成為現在的自己，並為未來的我奠定了基礎。我感謝這段青春，它讓我學會了如何尋找溫暖，如何成長和堅持。

寫下這些回憶和思考，讓我感到宇宙的寬廣和生命的美好。我期待著未來的每一天，因為我知道，我的青春將繼續充滿著温暖。

願我能在這個世界上留下屬於自己的痕跡。

愛你的，
[你的名字]
```


```python
劣币驱逐良币
```

“劣币驱逐良币”是经济学中的一个著名原理，也称为“戈resham定律”（Gresham’s Law），最早由16世纪的经济学家托马斯·格雷沙姆提出。该定律指出，在货币体系中，如果有两种货币（贬值货币和未贬值货币）同时流通，并且法律上规定二者具有相同的名义价值，那么实际价值较低的货币（劣币）将会逐渐取代实际价值较高的货币（良币），而良币则会被大家积存起来、消失在市场流通之中。

原因在于市场参与者更倾向于使用价值较低的货币进行交易，而将价值较高的货币留作积存或投资。举个例子，如果有两种硬币，一种是金币，另一种是相同面额但由较少金含量的金属混合物制成的币（或者是铜币、银币等），消费者和商人在日常交易中会倾向于保留金币，使用其他较低成本的货币完成交易。结果就是流通中的货币越来越多地由贬值的货币（劣币）构成，而含金量高的货币（良币）则被人们从流通中抽走。

这个原理不仅仅局限于货币，它还被广泛地应用于信息经济学、市场经济学等其他领域，用来描述低质量商品驱逐高质量商品的现象。例如，在投资市场，劣质的投资产品如果提供看似更高的回报，可能会吸引更多的投资者，从而导致有价值的投资产品被边缘化。在信息传播中，不真实或者误导性的信息（“假新闻”）可能因为更具戏剧性、更能吸引注意力而比真实的、严谨的报道更为流行。


```python
举个信息经济学、市场经济学的例子。或者其他领域的例子可以吗？我理解起来有点费力。通俗一点
```

当然可以！让我们以一个通俗的例子来解释这个概念。

想象一下，你去一个菜市场购买水果。在某个摊位上，有两种苹果：一种是新鲜、甜美的优质苹果，另一种是又小又酸的劣质苹果。价格上，劣质苹果便宜得多。

现在假设你是一个聪明的消费者，你希望购买最好的苹果。然而，由于劣质苹果的价格更低，很多人会倾向于购买劣质苹果，而不是质量更好的苹果。

这种情况下，劣质苹果的供应量会增加，而优质苹果的供应量会减少。因为卖家们意识到劣质苹果更受欢迎，他们会更多地种植劣质苹果，而减少种植优质苹果的数量。

随着时间的推移，市场上的优质苹果供应逐渐减少，而劣质苹果供应逐渐增加。最终，你很难找到好吃的苹果，因为劣质苹果占据了市场的主导地位。

这个例子就是劣币驱逐良币的市场现象。劣质产品的低价吸引了更多的消费者，导致优质产品的供应减少。最终，市场上优质产品的选择变得有限，而劣质产品占据了市场的主导地位。

这个例子可以帮助我们理解劣币驱逐良币的概念在市场经济中的应用。
