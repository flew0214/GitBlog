# 1212


```python
这是我的数据样板抽样2条，因为这两条有个特别的计算逻辑
HS code	判定模型	判定条件数	复核栏位	运算条件	逻辑分类	是否拆分\n(0/1)	拆解符	运算逻辑	举例	Element0	Element1	Element2	Element3	Element4	Element5	Element6	Element7	Element8	Element9
14	3919109900	1	4	7	200	g	1	"*"	X2	4|3|绝缘耐热固定|棕色带状|成卷|是单面自粘|聚酰亚胺,硅胶粘结剂|长宽厚20000*2...	4	3	绝缘耐热固定	棕色带状	成卷	是单面自粘	聚酰亚胺,硅胶粘结剂	长宽厚20000*25*0.06mm	日东电工牌/NITTO DENKO牌	{型号}
20	8482400090	1	1	3	3	e	1	","	X2/X1	4|3|滚针轴承|滚子直径2mm,滚针长度6.8mm|米思米牌/MISUMI牌|{型号}	4	3	滚针轴承	滚子直径2mm,滚针长度6.8mm	米思米牌/MISUMI牌	{型号}	None	None	None	None

以下代码是用来从举例中拆分数据，来判断是否满足条件。
复核栏位的值就是后面第几个Element需要判断，判断的方法根据<逻辑分类>和<运算条件>计算。
接着我需要增加一个处理判断逻辑：
1. 如果<是否拆分(0/1)>= 1的话，就需要应用这个处理逻辑。
2. 需要处理的数据还是按照：复核栏位的值就是后面第几个Element需要处理
3. 处理逻辑分成两段：
 a. 拆分：根据<拆解符>的值来拆分数据
 b. 拆分出来的数据还需要加工，比如写了X2，那就是要拆分出来的第二段作为结果。比如写了X2/X1，那就需要拿第二段/第一段来作为结果。这里要注意的是，这只是举例。并不一定只有X1,X2,运算方法也不光是/，还有其他运算符号。
这些处理过程的字段可以保留着，可以就用X1,X2,X3来存储拆分的字段。x_result作为最终需要判断的结果列。
然后用这个结果列去用判断的方法根据<逻辑分类>和<运算条件>计算。

我想要么先拆解下这段功能：
函数1
1. 根据<拆解符>的值来拆分数据，然后提取其中的数字部分。存到对应的字段里。预设X1,X2,X3,X4,X5、X_result字段要么。
2. 根据运算逻辑，设定对应的变量去存储X1,X2 。然后应用EVAL去处理？你觉得咋样。

def split_and_add_columns(df, column_name):
    # 使用str.split拆分指定列的内容，expand=True将返回DataFrame
    split_df = df[column_name].str.split('|', expand=True)
    
    # 预设最多9个字段
    max_columns = 10
    
    # 如果拆分列数小于10，则填充空值
    for i in range(max_columns):
        if i < split_df.shape[1]:  # 如果拆分后有该列，则填充
            df[f'Element{i}'] = split_df.iloc[:, i]
        else:  # 否则填充空值
            df[f'Element{i}'] = None
    
    return df

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.search(r"[-+]?\d*\.\d+|\d+", str(value))
    return float(match.group(0)) if match else None

def ensure_numeric(value):
    """
    确保将值转换为数字类型，如果无法转换，返回 NaN。
    """
    try:
        return pd.to_numeric(value, errors='coerce')
    except Exception:
        return None

def compare_values(value1, value2, comparison):
    """
    根据比较类型执行大于、小于、大于等于、小于等于的比较。
    """
    if comparison == 'greater':
        return value1 > value2
    elif comparison == 'greater_equal':
        return value1 >= value2
    elif comparison == 'less':
        return value1 < value2
    elif comparison == 'less_equal':
        return value1 <= value2
    return False

def apply_logic_condition(row, df):
    """
    根据逻辑代码判断指定列的值
    :param row: 当前行
    :param df: 数据框
    :return: 返回布尔值（1 或 0）
    """
    logic_code = row['逻辑分类']
    condition_value = row['运算条件']
    column_index = row['复核栏位']
    
    # 获取目标列名
    column_name = f'Element{column_index}'

    # 对于文本型判断（a, b, c），不需要提取数字，只需要文本匹配
    if logic_code in ['a', 'b', 'c']:
        row_value = str(row[column_name])
        
        if logic_code == 'a':  # 等于
            return 1 if row_value == str(condition_value) else 0
        elif logic_code == 'b':  # 包含
            return 1 if pd.Series(row[column_name]).str.contains(str(condition_value), na=False).any() else 0
        elif logic_code == 'c':  # 不包含
            return 1 if not pd.Series(row[column_name]).str.contains(str(condition_value), na=False).any() else 0

    # 对于数字型判断（d, e, f, g），需要提取数字并进行比较
    row_value_numeric = extract_number_from_element(row[column_name])

    if row_value_numeric is None:
        # 如果没有提取到数字，直接返回 False 或 0，这取决于具体业务逻辑
        return 0  # 这里返回0，表示不符合条件

    # 确保运算条件是数字
    condition_value_numeric = ensure_numeric(condition_value)
    if condition_value_numeric is None:
        raise ValueError(f"Invalid numeric value in condition: {condition_value}")

    # 逻辑代码对应的判断条件
    if logic_code == 'd':  # 大于
        return 1 if compare_values(row_value_numeric, condition_value_numeric, 'greater') else 0
    elif logic_code == 'e':  # 大于等于
        return 1 if compare_values(row_value_numeric, condition_value_numeric, 'greater_equal') else 0
    elif logic_code == 'f':  # 小于
        return 1 if compare_values(row_value_numeric, condition_value_numeric, 'less') else 0
    elif logic_code == 'g':  # 小于等于
        return 1 if compare_values(row_value_numeric, condition_value_numeric, 'less_equal') else 0
    else:
        raise ValueError(f"Unsupported logic code: {logic_code}")
```


      File "C:\Users\sh1912\AppData\Local\Temp\ipykernel_36492\4083870552.py", line 1
        这是我的数据样板抽样2条，因为这两条有个特别的计算逻辑
                    ^
    SyntaxError: invalid character '，' (U+FF0C)
    



```python
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        # 只允许访问内置的数学操作符
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")


# 示例使用
variables = {'X1': 5, 'X2': 3, 'X3': 4}
expressions = ['X1/X2', 'X1+X2', 'X1*X3', 'X1+X2+X3', 'X1*(X2+X3)', 'X1*X2+X3']

for expr in expressions:
    try:
        result = safe_eval(expr, variables)
        print(f"{expr} = {result}")
    except Exception as e:
        print(f"Error evaluating {expr}: {e}")
```

    X1/X2 = 1.6666666666666667
    X1+X2 = 8
    X1*X3 = 20
    X1+X2+X3 = 12
    X1*(X2+X3) = 35
    X1*X2+X3 = 19
    


```python
# 测试用的数据列表，每个元素是一个字典，包含表达式和对应的变量定义
test_cases = [
    {'expression': 'X1/X2', 'variables': {'X1': 5, 'X2': 3}},
    {'expression': 'X1+X2', 'variables': {'X1': 51, 'X2': 3}},
    {'expression': 'X1*X3', 'variables': {'X1': 5, 'X3': 4}},
    {'expression': 'X1+X2+X3', 'variables': {'X1': 2, 'X2': 3, 'X3': 5}},
    {'expression': 'X1*(X2+X3)', 'variables': {'X1': 5, 'X2': 3, 'X3': 1}},
    {'expression': 'X1*X2+X3', 'variables': {'X1': 2, 'X2': 3, 'X3': 4}}
]

# 测试并打印结果
results = []
for case in test_cases:
    expr = case['expression']
    variables = case['variables']
    try:
        result = safe_eval(expr, variables)
        print(f"Expression: {expr} with variables {variables} = {result}")
        results.append(result)
    except Exception as e:
        print(f"Error evaluating {expr}: {e}")
        results.append(None)  # 或者你可以选择跳过这个表达式

print("Final results:", results)
```

    Expression: X1/X2 with variables {'X1': 5, 'X2': 3} = 1.6666666666666667
    Expression: X1+X2 with variables {'X1': 51, 'X2': 3} = 54
    Expression: X1*X3 with variables {'X1': 5, 'X3': 4} = 20
    Expression: X1+X2+X3 with variables {'X1': 2, 'X2': 3, 'X3': 5} = 10
    Expression: X1*(X2+X3) with variables {'X1': 5, 'X2': 3, 'X3': 1} = 20
    Expression: X1*X2+X3 with variables {'X1': 2, 'X2': 3, 'X3': 4} = 10
    Final results: [1.6666666666666667, 54, 20, 10, 20, 10]
    


```python
	HS code	判定模型	判定条件数	复核栏位	运算条件	逻辑分类	是否拆分\n(0/1)	拆解符	运算逻辑	举例	Element0	Element1	Element2	Element3	Element4	Element5	Element6	Element7	Element8	Element9
14	3919109900	1	4	7	200	g	1	"*"	X2	4|3|绝缘耐热固定|棕色带状|成卷|是单面自粘|聚酰亚胺,硅胶粘结剂|长宽厚20000*2...	4	3	绝缘耐热固定	棕色带状	成卷	是单面自粘	聚酰亚胺,硅胶粘结剂	长宽厚20000*25*0.06mm	日东电工牌/NITTO DENKO牌	{型号}
20	8482400090	1	1	3	3	e	1	","	X2/X1	4|3|滚针轴承|滚子直径2mm,滚针长度6.8mm|米思米牌/MISUMI牌|{型号}	4	3	滚针轴承	滚子直径2mm,滚针长度6.8mm	米思米牌/MISUMI牌	{型号}	None	None	None	None

接着我需要增加一个处理判断逻辑：
1. 如果<是否拆分(0/1)>= 1的话，就需要应用这个处理逻辑。
2. 需要处理的数据还是按照：复核栏位的值就是后面第几个Element需要处理
3. 处理逻辑分成两段：
 a. 拆分：根据<拆解符>的值来拆分数据
 b. 拆分出来的数据还需要加工，比如写了X2，那就是要拆分出来的第二段作为结果。比如写了X2/X1，那就需要拿第二段/第一段来作为结果。这里要注意的是，这只是举例。并不一定只有X1,X2,运算方法也不光是/，还有其他运算符号。
这些处理过程的字段可以保留着，可以就用X1,X2,X3来存储拆分的字段。x_result作为最终需要判断的结果列。
然后用这个结果列去用判断的方法根据<逻辑分类>和<运算条件>计算。

运算部分就用下面这段，封装到一个函数里吧。
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        # 只允许访问内置的数学操作符
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")
    
那么还缺少一个拆分字符串、提取数字部分，到新字段X1\X2\X3\X4\X5 的过程。
运算结果就存入x_result里



```


      File "C:\Users\sh1912\AppData\Local\Temp\ipykernel_33012\4057699693.py", line 1
        HS code	判定模型	判定条件数	复核栏位	运算条件	逻辑分类	是否拆分\n(0/1)	拆解符	运算逻辑	举例	Element0	Element1	Element2	Element3	Element4	Element5	Element6	Element7	Element8	Element9
           ^
    SyntaxError: invalid syntax
    



```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.search(r"[-+]?\d*\.?\d+", str(value))
    return float(match.group(0)) if match else None

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def process_split_logic(df):
    def split_data(row):
        if row['是否拆分\n(0/1)'] >= 1 and isinstance(row['举例'], str):
            elements = [e.strip() for e in row['举例'].split(row['拆解符']) if e.strip()]
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'X{i}'] = element
                num = extract_number_from_element(element)
                if num is not None:
                    row[f'X{i}_num'] = num  # 提取并存储数字部分
        return row

    def apply_operation(row):
        operation = str(row['运算逻辑']).strip()
        if 'X' in operation and isinstance(operation, str):
            parts = operation.split('/')
            result = []
            for part in parts:
                if part.startswith('X'):
                    index = int(part[1:]) - 1  # 因为X是从1开始计数的
                    if f'X{index+1}_num' in row and row[f'X{index+1}_num'] is not None:
                        result.append(row[f'X{index+1}_num'])
            
            if len(result) == 2:  # 如果是二元操作
                num1 = result[0]
                num2 = result[1]
                if '/' in operation and num2 != 0:  # 防止除以零
                    row['x_result'] = num1 / num2
                elif '+' in operation:
                    row['x_result'] = num1 + num2
                elif '-' in operation:
                    row['x_result'] = num1 - num2
                elif '*' in operation:
                    row['x_result'] = num1 * num2
            elif len(result) == 1:
                row['x_result'] = result[0]
            else:
                row['x_result'] = None  # 如果没有匹配的操作，设置为None
        else:
            row['x_result'] = None  # 如果operation不是预期格式，设置为None
        
        return row

    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

# 示例使用
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df = process_split_logic(df)
print(df[['HS code', 'X1', 'X2', 'X1_num', 'X2_num', 'x_result']])
```

          HS code        X1         X2   X1_num  X2_num  x_result
    0  3919109900  长宽厚20000         25  20000.0    25.0      25.0
    1  8482400090   滚子直径2mm  滚针长度6.8mm      2.0     6.8       3.4
    

    C:\Users\sh1912\AppData\Local\Temp\ipykernel_33012\1773793265.py:1: DeprecationWarning: 
    Pyarrow will become a required dependency of pandas in the next major release of pandas (pandas 3.0),
    (to allow more performant data types, such as the Arrow string type, and better interoperability with other libraries)
    but was not found to be installed on your system.
    If this would cause problems for you,
    please provide us feedback at https://github.com/pandas-dev/pandas/issues/54466
            
      import pandas as pd
    


```python
df[['HS code', 'X1', 'X2', 'X1_num', 'X2_num', 'x_result']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>HS code</th>
      <th>X1</th>
      <th>X2</th>
      <th>X1_num</th>
      <th>X2_num</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>25</td>
      <td>20000.0</td>
      <td>25.0</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>滚针长度6.8mm</td>
      <td>2.0</td>
      <td>6.8</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>
</div>




```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def process_split_logic(df):
    def split_data(row):
        if row['是否拆分\n(0/1)'] >= 1 and isinstance(row['举例'], str):
            elements = [e.strip() for e in row['举例'].split(row['拆解符']) if e.strip()]
            all_numbers = []
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'X{i}'] = element
                numbers = extract_number_from_element(element)
                all_numbers.extend(numbers)
                for j, num in enumerate(numbers, start=1):
                    row[f'X{i}_num{j}'] = num
            
            # 如果某个元素中有多个数字，则按顺序分配给 X1_num, X2_num, ...
            for i, num in enumerate(all_numbers, start=1):
                row[f'X{i}_num'] = num
        
        return row

    def apply_operation(row):
        operation = str(row['运算逻辑']).strip()
        if 'X' in operation and isinstance(operation, str):
            parts = operation.split('/')
            result = []
            for part in parts:
                if part.startswith('X'):
                    index = int(part[1:]) - 1  # 因为X是从1开始计数的
                    if f'X{index+1}_num' in row and row[f'X{index+1}_num'] is not None:
                        result.append(row[f'X{index+1}_num'])
            
            if len(result) == 2:  # 如果是二元操作
                num1 = result[0]
                num2 = result[1]
                if '/' in operation and num2 != 0:  # 防止除以零
                    row['x_result'] = num1 / num2
                elif '+' in operation:
                    row['x_result'] = num1 + num2
                elif '-' in operation:
                    row['x_result'] = num1 - num2
                elif '*' in operation:
                    row['x_result'] = num1 * num2
            elif len(result) == 1:
                row['x_result'] = result[0]
            else:
                row['x_result'] = None  # 如果没有匹配的操作，设置为None
        else:
            row['x_result'] = None  # 如果operation不是预期格式，设置为None
        
        return row

    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

```


```python

# 示例使用
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df2 = process_split_logic(df)
```


```python
df2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>HS code</th>
      <th>X1</th>
      <th>X1_num</th>
      <th>X1_num1</th>
      <th>X2</th>
      <th>X2_num</th>
      <th>X2_num1</th>
      <th>X3</th>
      <th>X3_num</th>
      <th>X3_num1</th>
      <th>举例</th>
      <th>拆解符</th>
      <th>是否拆分\n(0/1)</th>
      <th>运算逻辑</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>20000.0</td>
      <td>20000.0</td>
      <td>25</td>
      <td>25.0</td>
      <td>25.0</td>
      <td>0.06mm</td>
      <td>0.06</td>
      <td>0.06</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>*</td>
      <td>1</td>
      <td>X2</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>滚针长度6.8mm</td>
      <td>6.8</td>
      <td>6.8</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>滚子直径2mm,滚针长度6.8mm</td>
      <td>,</td>
      <td>1</td>
      <td>X2/X1</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>
</div>




```python
df2[['HS code', 'X1', 'X2', 'X3', 'X1_num', 'X2_num', 'X3_num', 'x_result']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>HS code</th>
      <th>X1</th>
      <th>X2</th>
      <th>X3</th>
      <th>X1_num</th>
      <th>X2_num</th>
      <th>X3_num</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>25</td>
      <td>0.06mm</td>
      <td>20000.0</td>
      <td>25.0</td>
      <td>0.06</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>滚针长度6.8mm</td>
      <td>NaN</td>
      <td>2.0</td>
      <td>6.8</td>
      <td>NaN</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>
</div>



# 1224

AGV 热度管理进度，调查如下：
    1. Geek+ : 有热度管理功能，需要更新，启动热度管理功能。
        1. AGV系统有热度管理，其中货格热度由AGV系统设定，料箱热度由上游系统(WMS)推送给AGV系统。
          （AGV系统界面上可以设定热度管理时间周期。比如：0点~4点，AGV系统就会自动生成任务，进行库位调整。）
        2. 会在仿真验证的基础上，提供软件更新。
          （更新前会联络我们，确定更新推送时间。）
        * Geek+ 有接口可以更新料箱热度值。
    2. WMS ： 料箱热度的推送功能：在日常任务推送的时候，发送料箱热度值。
            a. 料箱热度的更新是WMS自动计算的，还是由人导入的？
               WMS不具备自动计算功能，需要人提供，导入界面。
            b. 商品热度 → 料箱热度的转换逻辑？
               目前没有
            c. 料箱热度是根据日常任务推送时推送，还是有独立接口推送的？（推送的逻辑，长期没有任务的料箱如何更新热度？）
               根据日常任务推送是推送料箱热度。
        2. 改修：？

    3. 体制建立：
        1. 料箱的热度设定逻辑(0-100)、更新频度(多长时间推送一次更新，还是实时由WMS生成推送)
        2. 定期的数据统计与监测（季度）


目前的状态，跟Geek+确认，大概需要多久？

* 企划有提供现场一份高频商品在AGV区域的清单。 目前，高高频商品已移出AGV保管区域。高频商品转移中。

* 搬家前有提供过一份商品频度清单,作用是把相同频度的商品集约在同热度等级的料箱里。


## 20241225

现状调查
    Geek+ : 确认如下：能提供系统更新，修复热度管理功能。
        1. AGV系统有热度管理，其中货格热度由AGV系统设定，料箱热度由上游系统(WMS)推送给AGV系统。
          有两种模式：
            1. 动态调整 - 业务过程中调整。
            2. 静态调整 - 业务停止时，由AGV系统自主下发调整。
            （AGV系统界面上可以设定热度管理时间周期。比如：0点~4点，AGV系统就会自动生成任务，进行库位调整。）
            热度管理具备功能：
                1. 区域阈值设定95%（可设定）：当货格占用率达到95%，就会优先次级任务区域去保管。确保货格不占满。
                2. 热度管理停止时间的设定
                3. 热度管理任务量设定
        * Geek+ 有接口可以更新料箱热度值。
    WMS ：
        1. 料箱热度的推送功能：在拉箱任务下发的时候，推送料箱热度值的。

现有问题点：
    Geek+ ：
        1. 仿真结果，功能未生效。
        2. 货格热度的颗粒度问题  ，只能单元格热度
        货架95%饱和率
        有接口 下发货箱热度，不影响WCS跟AGV的现有接口（心跳）.
        有统计货箱热度区的
    WMS ：
        1. 缺少料箱热度更新的功能。（理想状态是：WMS自动计算料箱热度值）
        2. 死库的料箱，热度值不会被上传。（只有有任务的料箱才能发送热度值）

方案一：
    Geek+ ：修复热度管理功能
    WMS：具备自动计算料箱热度功能、定期全量推送料箱热度。
方案二：
    Geek+ ：修复热度管理功能
    WMS：不具备自动计算功能，能界面操作，能手动设定料箱热度、支持批量上传。 
方案三：
    Geek+ ：修复热度管理功能
    WMS：不具备自动计算功能，也不能手动设定。
    MPT开发小工具：功能是批量上传料箱热度到AGV系统。（需要：1. geek+提供接口协议 2. 关闭WMS的随任务推送料箱热度功能）
方案四：
    Geek+ ：不能修复热度管理功能
    MPT开发小工具：功能是批量发送料箱搬运任务，从货格到货格的任务。（需要geek+提供接口协议）
方案五：
    Geek+ ：不能修复热度管理功能
    MPT运维：通过RMS系统界面，手动发送搬运任务，从货格到货格的任务。（现有）   

体制建立：
        1. 料箱的热度设定逻辑(0-100)、更新频度(多长时间推送一次更新，还是实时由WMS生成推送)
        2. 定期的数据统计与监测（季度）



目前的状态，跟Geek+确认，大概需要多久？

* 企划有提供现场一份高频商品在AGV区域的清单。 目前，高高频商品已移出AGV保管区域。高频商品转移中。

* 搬家前有提供过一份商品频度清单,作用是把相同频度的商品集约在同热度等级的料箱里。


## 20241226


```python

昨天晚上跟GEEK+联络过了，Geek+说已经可以启用热度管理了。
1. 货格热度只能到单元格，不能设定高低，内外（单双）。
2. 更新时间的话，我让geek+等我们通知，
（建议这周就不要去动了。怕升级影响设备运作。影响生产性）
3. 可以调用接口，批量发送货箱热度给AGV系统。（不影响现在通信。）
4. 目前的状态启用热度管理需要多久？调整好。
   geek+表示只能估算，有动态和静态两种模式，不同模式的时长不一样。   每小时400的量去评估。
  （日常任务中，也会重新把料箱打乱。）
热度管理具备功能：
    1. 区域阈值设定95%（可设定）：当货格占用率达到95%，就会优先次级任务区域去保管。确保货格不占满。
    2. 热度管理停止时间的设定
    3. 热度管理任务量设定
总结：
       1. 建议启用静态模式，每天正常业务结束后。开始调库。每天调整2小时(可调整）。然后让小车充电，确保第二天的业务运作负荷。 
       2. 动态调整模式：AGV系统会默认不充满20条任务（可调整），去做热度管理。可能会影响现场业务（毕竟会占用几台车去做移库）

帮我优化下说明结构和表达逻辑，优化和语言表达。可以使用表格，或者其他的排版。
 
```


      File "<tokenize>", line 8
        （日常任务中，也会重新把料箱打乱。）
        ^
    IndentationError: unindent does not match any outer indentation level
    



```python
我要对数据做个处理和加工，数据样品如下：
df.loc[df['是否拆分\n(0/1)']==1].head(2)

HS code	判定模型	判定条件数	复核栏位	运算条件	逻辑分类	是否拆分\n(0/1)	拆解符	运算逻辑	举例	Element0	Element1	Element2	Element3	Element4	Element5	Element6	Element7	Element8	Element9
14	3919109900	1	4	7	200	g	1	"*"	X2	4|3|绝缘耐热固定|棕色带状|成卷|是单面自粘|聚酰亚胺,硅胶粘结剂|长宽厚20000*2...	4	3	绝缘耐热固定	棕色带状	成卷	是单面自粘	聚酰亚胺,硅胶粘结剂	长宽厚20000*25*0.06mm	日东电工牌/NITTO DENKO牌	{型号}
20	8482400090	1	1	3	3	e	1	","	X2/X1	4|3|滚针轴承|滚子直径2mm,滚针长度6.8mm|米思米牌/MISUMI牌|{型号}	4	3	滚针轴承	滚子直径2mm,滚针长度6.8mm	米思米牌/MISUMI牌	{型号}	None	None	None	None

1. 根据 '是否拆分\n(0/1)'==1 来决定，是否要进行处理数据
2. 根据 '复核栏位' 的值N来决定，读取ElementN字段。
3. 根据 '拆解符' 的 值来决定，数据拆分以什么字符作为标识。默认最多拆分成5个。X1/X2/X3/X4/X5
4. 根据 X1/X2/X3/X4/X5的内容，提取数字部分，可以默认生成对应的五个字段，生成num字段，比如：X1_num
5. 根据 '运算逻辑'来计算，计算结果存入 'x_result' 中 

下面是用'举例'字段来处理的过程。结合上面的需求来实现。

import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def process_split_logic(df):
    def split_data(row):
        if row['是否拆分\n(0/1)'] >= 1 and isinstance(row['举例'], str):
            elements = [e.strip() for e in row['举例'].split(row['拆解符']) if e.strip()]
            all_numbers = []
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'X{i}'] = element
                numbers = extract_number_from_element(element)
                all_numbers.extend(numbers)
                for j, num in enumerate(numbers, start=1):
                    row[f'X{i}_num{j}'] = num
            
            # 如果某个元素中有多个数字，则按顺序分配给 X1_num, X2_num, ...
            for i, num in enumerate(all_numbers, start=1):
                row[f'X{i}_num'] = num
        
        return row

    def apply_operation(row):
        operation = str(row['运算逻辑']).strip()
        if 'X' in operation and isinstance(operation, str):
            parts = operation.split('/')
            result = []
            for part in parts:
                if part.startswith('X'):
                    index = int(part[1:]) - 1  # 因为X是从1开始计数的
                    if f'X{index+1}_num' in row and row[f'X{index+1}_num'] is not None:
                        result.append(row[f'X{index+1}_num'])
            
            if len(result) == 2:  # 如果是二元操作
                num1 = result[0]
                num2 = result[1]
                if '/' in operation and num2 != 0:  # 防止除以零
                    row['x_result'] = num1 / num2
                elif '+' in operation:
                    row['x_result'] = num1 + num2
                elif '-' in operation:
                    row['x_result'] = num1 - num2
                elif '*' in operation:
                    row['x_result'] = num1 * num2
            elif len(result) == 1:
                row['x_result'] = result[0]
            else:
                row['x_result'] = None  # 如果没有匹配的操作，设置为None
        else:
            row['x_result'] = None  # 如果operation不是预期格式，设置为None
        
        return row

    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

# 示例使用
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df = process_split_logic(df)
```


      File "C:\Users\sh1912\AppData\Local\Temp\ipykernel_22180\2745714190.py", line 1
        我要对数据做个处理和加工，数据样品如下：
                    ^
    SyntaxError: invalid character '，' (U+FF0C)
    



```python
# 示例使用
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df = process_split_logic(df)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>HS code</th>
      <th>X1</th>
      <th>X1_num</th>
      <th>X1_num1</th>
      <th>X2</th>
      <th>X2_num</th>
      <th>X2_num1</th>
      <th>X3</th>
      <th>X3_num</th>
      <th>X3_num1</th>
      <th>举例</th>
      <th>拆解符</th>
      <th>是否拆分\n(0/1)</th>
      <th>运算逻辑</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>20000.0</td>
      <td>20000.0</td>
      <td>25</td>
      <td>25.0</td>
      <td>25.0</td>
      <td>0.06mm</td>
      <td>0.06</td>
      <td>0.06</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>*</td>
      <td>1</td>
      <td>X2</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>2.0</td>
      <td>2.0</td>
      <td>滚针长度6.8mm</td>
      <td>6.8</td>
      <td>6.8</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>滚子直径2mm,滚针长度6.8mm</td>
      <td>,</td>
      <td>1</td>
      <td>X2/X1</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 示例使用
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df = process_split_logic(df)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>HS code</th>
      <th>X1</th>
      <th>X1_num1</th>
      <th>X2</th>
      <th>X2_num1</th>
      <th>X3</th>
      <th>X3_num1</th>
      <th>举例</th>
      <th>拆解符</th>
      <th>是否拆分\n(0/1)</th>
      <th>运算逻辑</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>20000.0</td>
      <td>25</td>
      <td>25.0</td>
      <td>0.06mm</td>
      <td>0.06</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>*</td>
      <td>1</td>
      <td>X2</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>2.0</td>
      <td>滚针长度6.8mm</td>
      <td>6.8</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>滚子直径2mm,滚针长度6.8mm</td>
      <td>,</td>
      <td>1</td>
      <td>X2/X1</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>
</div>



## 老北鼻优化，解决了num后面带1的问题。


```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def process_split_logic(df):
    def split_data(row):
        # 如果需要拆分
        if row['是否拆分\n(0/1)'] == 1 and isinstance(row['举例'], str):
            elements = [e.strip() for e in row['举例'].split(row['拆解符']) if e.strip()]
            all_numbers = []
            # 最多拆分5个部分
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'X{i}'] = element
                # 提取数字
                numbers = extract_number_from_element(element)
                if numbers:
                    row[f'X{i}_num'] = numbers[0]  # 只有一个数字时，直接赋值到 X_num 列
                    all_numbers.extend(numbers)
                else:
                    row[f'X{i}_num'] = None  # 如果没有数字，赋值为 None
            
        return row

    def apply_operation(row):
        operation = str(row['运算逻辑']).strip()
        if 'X' in operation and isinstance(operation, str):
            parts = operation.split('/')
            result = []
            for part in parts:
                if part.startswith('X'):
                    index = int(part[1:]) - 1  # 因为X是从1开始计数的
                    if f'X{index+1}_num' in row and row[f'X{index+1}_num'] is not None:
                        result.append(row[f'X{index+1}_num'])
            
            if len(result) == 2:  # 如果是二元操作
                num1 = result[0]
                num2 = result[1]
                if '/' in operation and num2 != 0:  # 防止除以零
                    row['x_result'] = num1 / num2
                elif '+' in operation:
                    row['x_result'] = num1 + num2
                elif '-' in operation:
                    row['x_result'] = num1 - num2
                elif '*' in operation:
                    row['x_result'] = num1 * num2
            elif len(result) == 1:
                row['x_result'] = result[0]
            else:
                row['x_result'] = None  # 如果没有匹配的操作，设置为None
        else:
            row['x_result'] = None  # 如果operation不是预期格式，设置为None
        
        return row

    # 应用拆分逻辑和运算逻辑
    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

# 示例数据
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df = process_split_logic(df)
```

          HS code        X1   X1_num         X2  X2_num      X3  X3_num  \
    0  3919109900  长宽厚20000  20000.0         25    25.0  0.06mm    0.06   
    1  8482400090   滚子直径2mm      2.0  滚针长度6.8mm     6.8     NaN     NaN   
    
                       举例 拆解符  是否拆分\n(0/1)   运算逻辑  x_result  
    0  长宽厚20000*25*0.06mm   *            1     X2      25.0  
    1   滚子直径2mm,滚针长度6.8mm   ,            1  X2/X1       3.4  
    


```python
df
```

## 函数全部参数化


```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def process_split_logic(df, hs_code_col='HS code', x_col_prefix='X', num_col_suffix='_num', 
                        example_col='举例', split_char_col='拆解符', split_flag_col='是否拆分\n(0/1)', 
                        operation_col='运算逻辑', result_col='x_result'):
    """
    处理拆分逻辑并执行运算逻辑。可以通过参数修改字段名称。

    :param df: 输入的DataFrame
    :param hs_code_col: HS code字段的列名
    :param x_col_prefix: X列的前缀
    :param num_col_suffix: 数字列的后缀
    :param example_col: 举例列的列名
    :param split_char_col: 拆解符列的列名
    :param split_flag_col: 是否拆分标志列的列名
    :param operation_col: 运算逻辑列的列名
    :param result_col: 结果列的列名
    :return: 处理后的DataFrame
    """

    def split_data(row):
        # 如果需要拆分
        if row[split_flag_col] == 1 and isinstance(row[example_col], str):
            elements = [e.strip() for e in row[example_col].split(row[split_char_col]) if e.strip()]
            all_numbers = []
            # 最多拆分5个部分
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'{x_col_prefix}{i}'] = element
                # 提取数字
                numbers = extract_number_from_element(element)
                if numbers:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = numbers[0]  # 只有一个数字时，直接赋值到 X_num 列
                    all_numbers.extend(numbers)
                else:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = None  # 如果没有数字，赋值为 None
            
        return row

    def apply_operation(row):
        operation = str(row[operation_col]).strip()
        if 'X' in operation and isinstance(operation, str):
            parts = operation.split('/')
            result = []
            for part in parts:
                if part.startswith('X'):
                    index = int(part[1:]) - 1  # 因为X是从1开始计数的
                    if f'{x_col_prefix}{index+1}{num_col_suffix}' in row and row[f'{x_col_prefix}{index+1}{num_col_suffix}'] is not None:
                        result.append(row[f'{x_col_prefix}{index+1}{num_col_suffix}'])
            
            if len(result) == 2:  # 如果是二元操作
                num1 = result[0]
                num2 = result[1]
                if '/' in operation and num2 != 0:  # 防止除以零
                    row[result_col] = num1 / num2
                elif '+' in operation:
                    row[result_col] = num1 + num2
                elif '-' in operation:
                    row[result_col] = num1 - num2
                elif '*' in operation:
                    row[result_col] = num1 * num2
            elif len(result) == 1:
                row[result_col] = result[0]
            else:
                row[result_col] = None  # 如果没有匹配的操作，设置为None
        else:
            row[result_col] = None  # 如果operation不是预期格式，设置为None
        
        return row

    # 应用拆分逻辑和运算逻辑
    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

```


```python
# 示例使用
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm'},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm'}
])

df = process_split_logic(df)
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>HS code</th>
      <th>X1</th>
      <th>X1_num</th>
      <th>X2</th>
      <th>X2_num</th>
      <th>X3</th>
      <th>X3_num</th>
      <th>举例</th>
      <th>拆解符</th>
      <th>是否拆分\n(0/1)</th>
      <th>运算逻辑</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>20000.0</td>
      <td>25</td>
      <td>25.0</td>
      <td>0.06mm</td>
      <td>0.06</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>*</td>
      <td>1</td>
      <td>X2</td>
      <td>25.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>2.0</td>
      <td>滚针长度6.8mm</td>
      <td>6.8</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>滚子直径2mm,滚针长度6.8mm</td>
      <td>,</td>
      <td>1</td>
      <td>X2/X1</td>
      <td>3.4</td>
    </tr>
  </tbody>
</table>
</div>



## 换成动态判断需要处理的字段


```python
### 问题是不支持复杂运算
```


```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def get_element_column(row, element_prefix='Element'):
    """
    根据复核栏位值，动态选择对应的 Element 列。

    :param row: 行数据
    :param element_prefix: Element 列的前缀，例如 'Element'
    :return: 选择的 Element 列值
    """
    review_column = row['复核栏位']
    element_column = f'{element_prefix}{review_column}'
    return row.get(element_column, None)

def process_split_logic(df, hs_code_col='HS code', x_col_prefix='X', num_col_suffix='_num', 
                        example_col='举例', split_char_col='拆解符', split_flag_col='是否拆分\n(0/1)', 
                        operation_col='运算逻辑', result_col='x_result', element_prefix='Element'):
    """
    处理拆分逻辑并执行运算逻辑。可以通过参数修改字段名称。

    :param df: 输入的DataFrame
    :param hs_code_col: HS code字段的列名
    :param x_col_prefix: X列的前缀
    :param num_col_suffix: 数字列的后缀
    :param example_col: 举例列的列名
    :param split_char_col: 拆解符列的列名
    :param split_flag_col: 是否拆分标志列的列名
    :param operation_col: 运算逻辑列的列名
    :param result_col: 结果列的列名
    :param element_prefix: Element 列的前缀
    :return: 处理后的DataFrame
    """
    def split_data(row):
        # 使用复核栏位动态选择需要的Element列
        example_value = get_element_column(row, element_prefix)
        if example_value and row[split_flag_col] == 1 and isinstance(example_value, str):
            elements = [e.strip() for e in example_value.split(row[split_char_col]) if e.strip()]
            all_numbers = []
            # 最多拆分5个部分
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'{x_col_prefix}{i}'] = element
                # 提取数字
                numbers = extract_number_from_element(element)
                if numbers:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = numbers[0]  # 只有一个数字时，直接赋值到 X_num 列
                    all_numbers.extend(numbers)
                else:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = None  # 如果没有数字，赋值为 None
            
        return row

    def apply_operation(row):
        operation = str(row[operation_col]).strip()
        if 'X' in operation and isinstance(operation, str):
            parts = operation.split('/')
            result = []
            for part in parts:
                if part.startswith('X'):
                    index = int(part[1:]) - 1  # 因为X是从1开始计数的
                    if f'{x_col_prefix}{index+1}{num_col_suffix}' in row and row[f'{x_col_prefix}{index+1}{num_col_suffix}'] is not None:
                        result.append(row[f'{x_col_prefix}{index+1}{num_col_suffix}'])
            
            if len(result) == 2:  # 如果是二元操作
                num1 = result[0]
                num2 = result[1]
                if '/' in operation and num2 != 0:  # 防止除以零
                    row[result_col] = num1 / num2
                elif '+' in operation:
                    row[result_col] = num1 + num2
                elif '-' in operation:
                    row[result_col] = num1 - num2
                elif '*' in operation:
                    row[result_col] = num1 * num2
            elif len(result) == 1:
                row[result_col] = result[0]
            else:
                row[result_col] = None  # 如果没有匹配的操作，设置为None
        else:
            row[result_col] = None  # 如果operation不是预期格式，设置为None
        
        return row

    # 应用拆分逻辑和运算逻辑
    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

```


```python
# 示例数据
df = pd.DataFrame([
    {'HS code': 3919109900,'是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 3919109902,'是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '*', '运算逻辑': 'X1+X2+X3', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 3919109901,'是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '*', '运算逻辑': 'X1*X2', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 8482400090,'是否拆分\n(0/1)': 1, '复核栏位': 4, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '滚针轴承', 'Element4': '滚子直径2mm,滚针长度6.8mm', 'Element5': '米思米牌/MISUMI牌', 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None}
])

df = process_split_logic(df)

```

## 运用 safe_eval来支持复杂运算


```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def get_element_column(row, element_prefix='Element'):
    """
    根据复核栏位值，动态选择对应的 Element 列。

    :param row: 行数据
    :param element_prefix: Element 列的前缀，例如 'Element'
    :return: 选择的 Element 列值
    """
    review_column = row['复核栏位']
    element_column = f'{element_prefix}{review_column}'
    return row.get(element_column, None)

def process_split_logic(df, hs_code_col='HS code', x_col_prefix='X', num_col_suffix='_num', 
                        example_col='举例', split_char_col='拆解符', split_flag_col='是否拆分\n(0/1)', 
                        operation_col='运算逻辑', result_col='x_result', element_prefix='Element'):
    """
    处理拆分逻辑并执行运算逻辑。可以通过参数修改字段名称。

    :param df: 输入的DataFrame
    :param hs_code_col: HS code字段的列名
    :param x_col_prefix: X列的前缀
    :param num_col_suffix: 数字列的后缀
    :param example_col: 举例列的列名
    :param split_char_col: 拆解符列的列名
    :param split_flag_col: 是否拆分标志列的列名
    :param operation_col: 运算逻辑列的列名
    :param result_col: 结果列的列名
    :param element_prefix: Element 列的前缀
    :return: 处理后的DataFrame
    """
    
    def split_data(row):
        # 使用复核栏位动态选择需要的Element列
        example_value = get_element_column(row, element_prefix)
        if example_value and row[split_flag_col] == 1 and isinstance(example_value, str):
            elements = [e.strip() for e in example_value.split(row[split_char_col]) if e.strip()]
            all_numbers = []
            # 最多拆分5个部分
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'{x_col_prefix}{i}'] = element
                # 提取数字
                numbers = extract_number_from_element(element)
                if numbers:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = numbers[0]  # 只有一个数字时，直接赋值到 X_num 列
                    all_numbers.extend(numbers)
                else:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = None  # 如果没有数字，赋值为 None
            
        return row

    def apply_operation(row):
        operation = str(row[operation_col]).strip()
        if 'X' in operation and isinstance(operation, str):
            # 提取 X 列的值
            variables = {}
            for i in range(1, 6):  # 假设最多有 5 个元素 X1, X2, ..., X5
                num_col = f'{x_col_prefix}{i}{num_col_suffix}'
                if num_col in row and row[num_col] is not None:
                    variables[f'X{i}'] = row[num_col]
            
            # 如果有有效的 X 值，使用 safe_eval 来计算表达式
            if variables:
                try:
                    result = safe_eval(operation, variables)
                    row[result_col] = result
                except Exception as e:
                    row[result_col] = None  # 如果计算失败，设置为 None
            else:
                row[result_col] = None  # 如果没有找到有效的 X 值，设置为 None
        else:
            row[result_col] = None  # 如果运算逻辑格式不正确，设置为 None
        
        return row

    # 应用拆分逻辑和运算逻辑
    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

```


```python

# 示例数据
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '*', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 3919109902, '是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '*', '运算逻辑': 'X1+X2+X3', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 3919109901, '是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '*', '运算逻辑': 'X1*X2', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '复核栏位': 4, '拆解符': ',', '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '滚针轴承', 'Element4': '滚子直径2mm,滚针长度6.8mm', 'Element5': '米思米牌/MISUMI牌', 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None}
])

df = process_split_logic(df)


```


```python
df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Element0</th>
      <th>Element1</th>
      <th>Element2</th>
      <th>Element3</th>
      <th>Element4</th>
      <th>Element5</th>
      <th>Element6</th>
      <th>Element7</th>
      <th>Element8</th>
      <th>Element9</th>
      <th>HS code</th>
      <th>X1</th>
      <th>X1_num</th>
      <th>X2</th>
      <th>X2_num</th>
      <th>X3</th>
      <th>X3_num</th>
      <th>举例</th>
      <th>复核栏位</th>
      <th>拆解符</th>
      <th>是否拆分\n(0/1)</th>
      <th>运算逻辑</th>
      <th>x_result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>3919109900</td>
      <td>长宽厚20000</td>
      <td>20000.000</td>
      <td>25</td>
      <td>25.000</td>
      <td>0.06mm</td>
      <td>0.060</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>3</td>
      <td>*</td>
      <td>1</td>
      <td>X2</td>
      <td>25.000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>3919109902</td>
      <td>长宽厚20000</td>
      <td>20000.000</td>
      <td>25</td>
      <td>25.000</td>
      <td>0.06mm</td>
      <td>0.060</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>3</td>
      <td>*</td>
      <td>1</td>
      <td>X1+X2+X3</td>
      <td>20025.060</td>
    </tr>
    <tr>
      <th>2</th>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>3919109901</td>
      <td>长宽厚20000</td>
      <td>20000.000</td>
      <td>25</td>
      <td>25.000</td>
      <td>0.06mm</td>
      <td>0.060</td>
      <td>长宽厚20000*25*0.06mm</td>
      <td>3</td>
      <td>*</td>
      <td>1</td>
      <td>X1*X2</td>
      <td>500000.000</td>
    </tr>
    <tr>
      <th>3</th>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>滚针轴承</td>
      <td>滚子直径2mm,滚针长度6.8mm</td>
      <td>米思米牌/MISUMI牌</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>8482400090</td>
      <td>滚子直径2mm</td>
      <td>2.000</td>
      <td>滚针长度6.8mm</td>
      <td>6.800</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>滚子直径2mm,滚针长度6.8mm</td>
      <td>4</td>
      <td>,</td>
      <td>1</td>
      <td>X2/X1</td>
      <td>3.400</td>
    </tr>
  </tbody>
</table>
</div>



## 兼容拆分符带双引号的问题"*"


```python
import pandas as pd
import re
import operator

# 定义支持的操作符
operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.truediv,
}

def extract_number_from_element(value):
    """
    从字符串中提取数字部分，支持整数和浮动数值。
    会去掉单位，只提取数字部分。
    """
    match = re.findall(r"[-+]?\d*\.?\d+", str(value))
    return [float(m) for m in match if m] if match else []

def safe_eval(expression, variables):
    """
    安全地评估给定的数学表达式。
    
    :param expression: 包含运算逻辑的字符串，例如 "X1+X2", "X1*X3"
    :param variables: 一个字典，包含变量名到数值的映射，例如 {'X1': 5, 'X2': 3}
    :return: 表达式的计算结果
    """
    # 将表达式中的变量替换为实际值
    for var_name, value in variables.items():
        expression = expression.replace(var_name, str(value))
    
    try:
        # 使用 eval() 在安全的环境中计算表达式
        return eval(expression, {"__builtins__": None}, operations)
    except Exception as e:
        raise ValueError(f"Error evaluating expression: {e}")

def get_element_column(row, element_prefix='Element'):
    """
    根据复核栏位值，动态选择对应的 Element 列。

    :param row: 行数据
    :param element_prefix: Element 列的前缀，例如 'Element'
    :return: 选择的 Element 列值
    """
    review_column = row['复核栏位']
    element_column = f'{element_prefix}{review_column}'
    return row.get(element_column, None)

def process_split_logic(df, hs_code_col='HS code', x_col_prefix='X', num_col_suffix='_num', 
                        example_col='举例', split_char_col='拆解符', split_flag_col='是否拆分\n(0/1)', 
                        operation_col='运算逻辑', result_col='x_result', element_prefix='Element'):
    """
    处理拆分逻辑并执行运算逻辑。可以通过参数修改字段名称。

    :param df: 输入的DataFrame
    :param hs_code_col: HS code字段的列名
    :param x_col_prefix: X列的前缀
    :param num_col_suffix: 数字列的后缀
    :param example_col: 举例列的列名
    :param split_char_col: 拆解符列的列名
    :param split_flag_col: 是否拆分标志列的列名
    :param operation_col: 运算逻辑列的列名
    :param result_col: 结果列的列名
    :param element_prefix: Element 列的前缀
    :return: 处理后的DataFrame
    """
    
    def split_data(row):
        # 使用复核栏位动态选择需要的Element列
        example_value = get_element_column(row, element_prefix)
        if example_value and row[split_flag_col] == 1 and isinstance(example_value, str):
            split_char = row[split_char_col]
            # 去掉拆解符中的引号（单引号和双引号）
            split_char = split_char.replace('"', '').replace("'", '')

            # 使用去除引号后的拆解符来拆分字符串
            elements = [e.strip() for e in example_value.split(split_char) if e.strip()]
            all_numbers = []
            # 最多拆分5个部分
            for i, element in enumerate(elements[:5], start=1):  # 假设最多有5个元素被拆分
                row[f'{x_col_prefix}{i}'] = element
                # 提取数字
                numbers = extract_number_from_element(element)
                if numbers:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = numbers[0]  # 只有一个数字时，直接赋值到 X_num 列
                    all_numbers.extend(numbers)
                else:
                    row[f'{x_col_prefix}{i}{num_col_suffix}'] = None  # 如果没有数字，赋值为 None
            
        return row

    def apply_operation(row):
        operation = str(row[operation_col]).strip()
        if 'X' in operation and isinstance(operation, str):
            # 提取 X 列的值
            variables = {}
            for i in range(1, 6):  # 假设最多有 5 个元素 X1, X2, ..., X5
                num_col = f'{x_col_prefix}{i}{num_col_suffix}'
                if num_col in row and row[num_col] is not None:
                    variables[f'X{i}'] = row[num_col]
            
            # 如果有有效的 X 值，使用 safe_eval 来计算表达式
            if variables:
                try:
                    result = safe_eval(operation, variables)
                    row[result_col] = result
                except Exception as e:
                    row[result_col] = None  # 如果计算失败，设置为 None
            else:
                row[result_col] = None  # 如果没有找到有效的 X 值，设置为 None
        else:
            row[result_col] = None  # 如果运算逻辑格式不正确，设置为 None
        
        return row

    # 应用拆分逻辑和运算逻辑
    df = df.apply(split_data, axis=1)
    df = df.apply(apply_operation, axis=1)
    return df

# 示例数据
df = pd.DataFrame([
    {'HS code': 3919109900, '是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '"*"', '运算逻辑': 'X2', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 3919109902, '是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '"*"', '运算逻辑': 'X1+X2+X3', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 3919109901, '是否拆分\n(0/1)': 1, '复核栏位': 3, '拆解符': '"*"', '运算逻辑': 'X1*X2', '举例': '长宽厚20000*25*0.06mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '长宽厚20000*25*0.06mm', 'Element4': None, 'Element5': None, 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None},
    {'HS code': 8482400090, '是否拆分\n(0/1)': 1, '复核栏位': 4, '拆解符': "','", '运算逻辑': 'X2/X1', '举例': '滚子直径2mm,滚针长度6.8mm', 'Element0': None, 'Element1': None, 'Element2': None, 'Element3': '滚针轴承', 'Element4': '滚子直径2mm,滚针长度6.8mm', 'Element5': '米思米牌/MISUMI牌', 'Element6': None, 'Element7': None, 'Element8': None, 'Element9': None}
])

df = process_split_logic(df)

# 查看结果
print(df)

```
