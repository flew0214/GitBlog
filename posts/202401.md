```python
# 接下来的action
 1. 下周一例会的课题对应
 2. 广州出差的成果物
 3. 广州AGV的效率测算等指标
 4. 数据库备份体制的结构示意图
 5. 压测数据和真实数据的比较模型
```

# 0102

#### 广州agv 的改造构思alpha


```python
# 广州agv 的改造构思alpha
 1.AGV的活动行为能根据业务量临时分配角色（提货机、上架机、搬运机）
    1. 控制业务的平衡性
    2. 减少拥堵
    3. 提高AGV单次搬运的背箱数(任务集约度提高)
 2.提货作业货架（023）的上层货架使用：
        4~6层，高层货架因AGV有固定支撑架顶出设计，需要避开
 3.AGV提货任务的优先级更改：
        优先01、16的货架商品进行搬出。
        （前提：上架、提货任务能同时作业；目前受到优先级策略限制，提货任务会优先于其他任务）
 4.任务分发的逻辑优化
    现象（上架区）：
        AGV-1 从左向右进入巷道，AGV-2从右向做进入巷道
        AGV-1 放在上架作业货架并不集中在一个货架上，横跨多个货架。造成拥堵。
    对策：
        如果能优先某一辆AGV集中接收某一个货架区域的料箱，就能减少拥堵的风险。
    系统功能：
        大宇宙：任务能限定AGV车、
        GEEK+： 任务集约分配的优化、AGV角色的设定（限制可上架任务的AGV的数量）
            
```

#### AGV效率 @_@


```python
AGV效率的计算：
    1.概述：计算AGV执行一次完整的搬运任务的轨迹，几个料盒时间序列。
    2.字段：
        任务单号：
            AGVID + 开始时间 + 结束时间
            AGV_ID + TASK_MODE + 开始时间 + 结束时间
        任务开始时间：
        任务结束时间：
        任务时长：
        任务数：

```


```python
任务数的直方图
任务数与任务时长的关系
时长/任务数与 任务数和任务时长的关系
```


```python
AGV 故障率
AGV LT(20分钟以上)

```

#### VUE 的学习


```python
1.安装npm
https://npmmirror.com/

2.安装cli
https://cli.vuejs.org/zh/guide/installation.html

3.注册源
npm config set registry https://registry.npm.taobao.org

npm config get registry

4.create-project
https://cli.vuejs.org/zh/guide/creating-a-project.html
https://zhuanlan.zhihu.com/p/666412575

5.做好的demo
http://192.168.64.208:8080/
```


```python

```

#### 估算滚筒线段数


```python
import pandas as pd

data = '''
10006	10006	10006	10016	10016	10016	10032	10032	10051	10051	10057	10057	10062	10062	10066	10066	10073	10073	10073	10073	10084	10084
10019	10010	10102	10019	10010	10103	10034	10039	10054	10105	10060	10106	10064	10070	10108	10107	10083	10109	10110	10111	10086	10112
10006	10006	10006	10016	10016	10016	10032	10032	10051	10051	10057	10057	10062	10062	10066	10066	10073	10073	10073	10073	10084	10084
10007	10007	10007	10017	10017	10017	10033	10033	10052	10052	10058	10058	10063	10063	10067	10067	10074	10074	10074	10074	10085	10085
10008	10008	10102	10018	10018	10103	10034	10039	10054	10053	10060	10059	10064	10070	10069	10068	10076	10075	10076	10076	10086	10112
10009	10009		10009	10009					10105		10106			10108	10107	10077	10109	10077	10077		
10019	10010		10019	10010												10078		10078	10078		
																10080		10079	10080		
																10081		10110	10081		
																10083			10082		
																			10111		
																					
20032	20032	20035	20035	20053	20053	20056	20056	20074	20074	20077	20077
20034	20079	20080	20079	20055	20081	20082	20081	20076	20083	20084	20083
20032	20032	20035	20035	20053	20053	20056	20056	20074	20074	20077	20077
20033	20033	20036	20036	20054	20054	20057	20057	20075	20075	20078	20078
20034	20034	20080	20079	20055	20055	20082	20081	20076	20076	20084	20083
	20035				20056				20077		
	20036				20057				20078		
	20079				20081				20083		
30015	30015	30038	30038
30017	30020	30040	30065
30015	30015	30038	30038
30016	30016	30039	30039
30017	30019	30040	30065
	30020		

'''

data_io = pd.io.common.StringIO(data)
df = pd.read_csv(data_io, sep="\t", header=None)

# 提取第一个字段并去重
unique_values = df[0].unique()

print(unique_values)
```

    [10006. 10019. 10007. 10008. 10009.    nan 20032. 20034. 20033. 30015.
     30017. 30016.]
    


```python
df_concat = pd.concat([df[col] for col in df.columns], ignore_index=True)
```


```python
df_concat.unique()
```




    array([10006., 10019., 10007., 10008., 10009.,    nan, 20032., 20034.,
           20033., 30015., 30017., 30016., 10010., 20079., 20035., 20036.,
           30020., 30019., 10102., 20080., 30038., 30040., 30039., 10016.,
           10017., 10018., 30065., 20053., 20055., 20054., 10103., 20081.,
           20056., 20057., 10032., 10034., 10033., 20082., 10039., 10051.,
           10054., 10052., 20074., 20076., 20075., 10105., 10053., 20083.,
           20077., 20078., 10057., 10060., 10058., 20084., 10106., 10059.,
           10062., 10064., 10063., 10070., 10066., 10108., 10067., 10069.,
           10107., 10068., 10073., 10083., 10074., 10076., 10077., 10078.,
           10080., 10081., 10109., 10075., 10110., 10079., 10111., 10082.,
           10084., 10086., 10085., 10112.])




```python
df_concat.nunique()
```




    83




```python
システム導入により、保守人員増を抑制し、物流業務の円滑な運営を確保
```

# 0105


```python
1. AGV效率
2. AGVLT
3. AGV作业时序
```

# 论证效率和任务发布方式（集中发布、还是分散发布）的关系性

要论证自动导引车（AGV）效率与其任务发布方式（集中发布或分散发布）的关系性，可以遵循以下步骤：

1. **研究背景**: 阐述AGV的基本工作原理及其在现代物流、制造业中的作用，简要介绍任务发布方式的定义及其在AGV系统中的重要性。

2. **理论基础**: 利用物流系统的理论，比如排队理论、库存控制等，说明不同任务发布方式对AGV系统运作的潜在影响。

3. **案例分析**: 选取某些实际案例，通过比较不同企业或场景下AGV系统集中发布任务与分散发布任务的效率数据，来支撑你的观点。

4. **模拟分析**: 设计模拟实验，比较在同一控制条件下，集中发布与分散发布对AGV完成任务的速度、准确性、能耗等方面的影响。

5. **数据呈现**: 利用统计学方法对收集或模拟的数据进行分析，图表或模型可以帮助论证不同任务发布方式对效率的具体影响。

6. **优缺点讨论**: 集中发布可能简化了管理过程，提高了系统稳定性，但可能出现瓶颈，影响响应速度。分散发布方式可能提高了灵活性和响应速度，但可能导致资源分配不均、系统复杂性增加。

7. **最佳实践**: 提出可能的最佳任务发布方式，例如在实时性要求不高时使用集中式发布，在实时性要求高、任务多样性大时采用分散式发布，或者是结合两者的混合模式。

8. **结论**: 根据研究与分析结果，总结AGV效率与任务发布方式的关系性，并提供相关建议。

请确保你的论证建立在可靠的数据和分析之上，同时考虑系统的具体应用背景以及不同场景下的适用性。

# 0111


```python

```


```python
现仓库捆包线逻辑和流程：
1. 捆包完进入滚筒线的商品：双码校验通过后，就判定为出货完成。
2. 当子件未全部通过滚筒线（双码校验），母件（第一箱）不会滚到打印贴标机的线段，停在前一个滚筒线段。
```

# 0112


```python
3号充电桩
#31109 13:47 电量53
    13：53 电量59 6.7min 本次充电：5312 mah
    13:56 脱离
 #31109 休息13:57 在边上休息

 #31111 13：59 电量51
        14:09  电量61
 #31111 14:14 在边上休息

 #31115 14:21 电量49
        15:00 走的，跑到了旁边各自休息。然后马上接其他任务走了
```


```python
15:14 6号站台 36个库位调车任务发出
    https://wms-ex.misumi.sh.cn/index.html?lang=zh&customer=msm-wms-prd
    工作台暂存任务可以看完成状态
```


```python
#
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
1	01100101	A6-01-01-01	6	无任务	 	api	2024-01-12 14:02:46
2	01100103	A6-01-01-02	6	任务下发	2A-031511	api	2024-01-12 15:15:17
3	01100105	A6-01-01-03	6	任务下发	2A-027828	api	2024-01-12 15:15:16
4	01100201	A6-01-02-01	6	任务下发	2A-027250	api	2024-01-12 15:15:16
5	01100203	A6-01-02-02	6	任务下发	2A-025751	api	2024-01-12 15:15:16
6	01100205	A6-01-02-03	6	任务下发	2A-021299	api	2024-01-12 15:15:16
7	01100301	A6-01-03-01	6	任务下发	2A-021236	api	2024-01-12 15:15:16
8	01100303	A6-01-03-02	6	周转箱到位	2A-021171	api	2024-01-12 15:17:30
9	01100305	A6-01-03-03	6	任务下发	2A-019621	api	2024-01-12 15:15:16
10	01100401	A6-01-04-01	6	任务下发	2A-019047	api	2024-01-12 15:15:16
11	01100403	A6-01-04-02	6	任务下发	2A-018665	api	2024-01-12 15:15:16
12	01100405	A6-01-04-03	6	任务下发	2A-018217	api	2024-01-12 15:15:16
13	01100501	A6-02-05-01	6	任务下发	2A-018178	api	2024-01-12 15:15:16
14	01100503	A6-02-05-02	6	任务下发	2A-017656	api	2024-01-12 15:15:16
15	01100505	A6-02-05-03	6	任务下发	2A-017453	api	2024-01-12 15:15:15
16	01100601	A6-02-06-01	6	任务下发	2A-017350	api	2024-01-12 15:15:15
17	01100603	A6-02-06-02	6	任务下发	2A-017251	api	2024-01-12 15:15:15
18	01100605	A6-02-06-03	6	周转箱到位	2A-017195	api	2024-01-12 15:18:01
19	01100701	A6-02-07-01	6	任务下发	2A-016341	api	2024-01-12 15:15:15
20	01100703	A6-02-07-02	6	任务下发	2A-016316	api	2024-01-12 15:15:15
21	01100705	A6-02-07-03	6	任务下发	2A-016163	api	2024-01-12 15:15:15

```


```python
#
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
1	01100101	A6-01-01-01	6	无任务	 	api	2024-01-12 14:02:46
2	01100103	A6-01-01-02	6	周转箱到位	2A-031511	api	2024-01-12 15:20:25
3	01100105	A6-01-01-03	6	周转箱到位	2A-027828	api	2024-01-12 15:40:31
4	01100201	A6-01-02-01	6	周转箱到位	2A-027250	api	2024-01-12 15:19:20
5	01100203	A6-01-02-02	6	周转箱到位	2A-025751	api	2024-01-12 15:23:58
6	01100205	A6-01-02-03	6	周转箱到位	2A-021299	api	2024-01-12 15:27:12
7	01100301	A6-01-03-01	6	周转箱到位	2A-021236	api	2024-01-12 15:38:31
8	01100303	A6-01-03-02	6	周转箱到位	2A-021171	api	2024-01-12 15:17:30
9	01100305	A6-01-03-03	6	周转箱到位	2A-019621	api	2024-01-12 15:39:51
10	01100401	A6-01-04-01	6	周转箱到位	2A-019047	api	2024-01-12 15:42:03
11	01100403	A6-01-04-02	6	周转箱到位	2A-018665	api	2024-01-12 15:42:57
12	01100405	A6-01-04-03	6	周转箱到位	2A-018217	api	2024-01-12 15:35:39
13	01100501	A6-02-05-01	6	周转箱到位	2A-018178	api	2024-01-12 15:32:40
14	01100503	A6-02-05-02	6	周转箱到位	2A-017656	api	2024-01-12 15:32:17
15	01100505	A6-02-05-03	6	周转箱到位	2A-017453	api	2024-01-12 15:30:10
16	01100601	A6-02-06-01	6	周转箱到位	2A-017350	api	2024-01-12 15:26:05
17	01100603	A6-02-06-02	6	周转箱到位	2A-017251	api	2024-01-12 15:34:01
18	01100605	A6-02-06-03	6	周转箱到位	2A-017195	api	2024-01-12 15:18:01
19	01100701	A6-02-07-01	6	周转箱到位	2A-016341	api	2024-01-12 15:31:18
20	01100703	A6-02-07-02	6	周转箱到位	2A-016316	api	2024-01-12 15:29:39
21	01100705	A6-02-07-03	6	周转箱到位	2A-016163	api	2024-01-12 15:36:13

```


```python
15:43完成
```


```python
半小时调出了36个
```


```python
系统查出库位使用了35个。其中一个任务的料箱在2号站台
```


```python
16:15 6号货架又开始绑定新的36个料盒
```


```python
16：22 开始调车
```


```python
	
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
1	01100101	A6-01-01-01	6	无任务	 	api	2024-01-12 14:02:46
2	01100103	A6-01-01-02	6	任务下发	2A-019033	api	2024-01-12 16:22:17
3	01100105	A6-01-01-03	6	任务下发	2A-014523	api	2024-01-12 16:22:17
4	01100201	A6-01-02-01	6	任务下发	2A-021299	api	2024-01-12 16:21:20
5	01100203	A6-01-02-02	6	任务下发	2A-019969	api	2024-01-12 16:21:20
6	01100205	A6-01-02-03	6	任务下发	2A-019947	api	2024-01-12 16:21:20
7	01100301	A6-01-03-01	6	任务下发	2A-019517	api	2024-01-12 16:21:20
8	01100303	A6-01-03-02	6	任务下发	2A-017451	api	2024-01-12 16:21:20
9	01100305	A6-01-03-03	6	任务下发	2A-017291	api	2024-01-12 16:21:20
10	01100401	A6-01-04-01	6	任务下发	2A-017232	api	2024-01-12 16:21:20
11	01100403	A6-01-04-02	6	任务下发	2A-016488	api	2024-01-12 16:21:20
12	01100405	A6-01-04-03	6	任务下发	2A-007101	api	2024-01-12 16:21:20
13	01100501	A6-02-05-01	6	任务下发	2A-005601	api	2024-01-12 16:21:19
14	01100503	A6-02-05-02	6	任务下发	2A-002721	api	2024-01-12 16:21:19
15	01100505	A6-02-05-03	6	任务下发	2A-019611	api	2024-01-12 16:19:00
16	01100601	A6-02-06-01	6	周转箱到位	2A-000582	api	2024-01-12 16:22:17
17	01100603	A6-02-06-02	6	任务下发	2A-030351	api	2024-01-12 16:18:09
18	01100605	A6-02-06-03	6	任务下发	2A-026942	api	2024-01-12 16:18:09
19	01100701	A6-02-07-01	6	任务下发	2A-017640	api	2024-01-12 16:18:09
20	01100703	A6-02-07-02	6	任务下发	2A-017433	api	2024-01-12 16:18:09
21	01100705	A6-02-07-03	6	任务下发	2A-016862	api	2024-01-12 16:18:09

```


```python
16：53时的状态
```


```python
	
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
1	01100101	A6-01-01-01	6	无任务	 	api	2024-01-12 14:02:46
2	01100103	A6-01-01-02	6	周转箱到位	2A-019033	api	2024-01-12 16:33:35
3	01100105	A6-01-01-03	6	周转箱到位	2A-014523	api	2024-01-12 16:44:18
4	01100201	A6-01-02-01	6	周转箱到位	2A-021299	api	2024-01-12 16:37:51
5	01100203	A6-01-02-02	6	周转箱到位	2A-019969	api	2024-01-12 16:29:42
6	01100205	A6-01-02-03	6	周转箱到位	2A-019947	api	2024-01-12 16:27:35
7	01100301	A6-01-03-01	6	周转箱到位	2A-019517	api	2024-01-12 16:36:20
8	01100303	A6-01-03-02	6	周转箱到位	2A-017451	api	2024-01-12 16:30:12
9	01100305	A6-01-03-03	6	周转箱到位	2A-017291	api	2024-01-12 16:40:19
10	01100401	A6-01-04-01	6	周转箱到位	2A-017232	api	2024-01-12 16:36:52
11	01100403	A6-01-04-02	6	周转箱到位	2A-016488	api	2024-01-12 16:30:34
12	01100405	A6-01-04-03	6	周转箱到位	2A-007101	api	2024-01-12 16:43:42
13	01100501	A6-02-05-01	6	任务下发	2A-005601	api	2024-01-12 16:21:19
14	01100503	A6-02-05-02	6	周转箱到位	2A-002721	api	2024-01-12 16:37:15
15	01100505	A6-02-05-03	6	周转箱到位	2A-019611	api	2024-01-12 16:23:55
16	01100601	A6-02-06-01	6	周转箱到位	2A-000582	api	2024-01-12 16:22:17
17	01100603	A6-02-06-02	6	周转箱到位	2A-030351	api	2024-01-12 16:23:32
18	01100605	A6-02-06-03	6	周转箱到位	2A-026942	api	2024-01-12 16:38:12
19	01100701	A6-02-07-01	6	周转箱到位	2A-017640	api	2024-01-12 16:46:54
20	01100703	A6-02-07-02	6	周转箱到位	2A-017433	api	2024-01-12 16:33:09
21	01100705	A6-02-07-03	6	周转箱到位	2A-016862	api	2024-01-12 16:32:32

```


```python
17:07
```


```python
#
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
1	01100101	A6-01-01-01	6	无任务	 	api	2024-01-12 14:02:46
2	01100103	A6-01-01-02	6	周转箱到位	2A-019033	api	2024-01-12 16:33:35
3	01100105	A6-01-01-03	6	周转箱到位	2A-014523	api	2024-01-12 16:44:18
4	01100201	A6-01-02-01	6	周转箱到位	2A-021299	api	2024-01-12 16:37:51
5	01100203	A6-01-02-02	6	周转箱到位	2A-019969	api	2024-01-12 16:29:42
6	01100205	A6-01-02-03	6	周转箱到位	2A-019947	api	2024-01-12 16:27:35
7	01100301	A6-01-03-01	6	周转箱到位	2A-019517	api	2024-01-12 16:36:20
8	01100303	A6-01-03-02	6	周转箱到位	2A-017451	api	2024-01-12 16:30:12
9	01100305	A6-01-03-03	6	周转箱到位	2A-017291	api	2024-01-12 16:40:19
10	01100401	A6-01-04-01	6	任务完成	2A-017232	api	2024-01-12 17:07:01
11	01100403	A6-01-04-02	6	任务完成	2A-016488	api	2024-01-12 17:06:45
12	01100405	A6-01-04-03	6	回库任务下发	2A-007101	api	2024-01-12 17:06:35
13	01100501	A6-02-05-01	6	回库任务下发	2A-005601	api	2024-01-12 17:06:07
14	01100503	A6-02-05-02	6	回库任务下发	2A-002721	api	2024-01-12 17:06:07
15	01100505	A6-02-05-03	6	回库任务下发	2A-019611	api	2024-01-12 17:05:25
16	01100601	A6-02-06-01	6	回库任务下发	2A-000582	api	2024-01-12 17:05:21
17	01100603	A6-02-06-02	6	无任务	 	api	2024-01-12 17:06:57
18	01100605	A6-02-06-03	6	无任务	 	api	2024-01-12 17:06:38
19	01100701	A6-02-07-01	6	回库任务下发	2A-017640	api	2024-01-12 17:05:21
20	01100703	A6-02-07-02	6	无任务	 	api	2024-01-12 17:05:43
21	01100705	A6-02-07-03	6	无任务	 	api	2024-01-12 17:05:22

```


```python
17：15
```


```python
#
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
16	01100601	A6-02-06-01	6	无任务	 	api	2024-01-12 17:07:16
17	01100603	A6-02-06-02	6	无任务	 	api	2024-01-12 17:06:57
18	01100605	A6-02-06-03	6	无任务	 	api	2024-01-12 17:06:38
19	01100701	A6-02-07-01	6	无任务	 	api	2024-01-12 17:07:40
20	01100703	A6-02-07-02	6	无任务	 	api	2024-01-12 17:05:43
21	01100705	A6-02-07-03	6	无任务	 	api	2024-01-12 17:05:22
22	01100801	A6-02-08-01	6	无任务	 	api	2024-01-12 17:14:30
23	01100803	A6-02-08-02	6	无任务	 	api	2024-01-12 17:12:19
24	01100805	A6-02-08-03	6	无任务	 	api	2024-01-12 17:05:01
25	01100901	A6-03-09-01	6	无任务	 	api	2024-01-12 17:03:39
26	01100903	A6-03-09-02	6	无任务	 	api	2024-01-12 17:03:23
27	01100905	A6-03-09-03	6	无任务	 	api	2024-01-12 17:03:05
28	01101001	A6-03-10-01	6	无任务	 	api	2024-01-12 17:04:20
29	01101003	A6-03-10-02	6	无任务	 	api	2024-01-12 17:03:59
30	01101005	A6-03-10-03	6	无任务	 	api	2024-01-12 17:01:14
31	01101101	A6-03-11-01	6	无任务	 	api	2024-01-12 17:00:48
32	01101103	A6-03-11-02	6	无任务	 	api	2024-01-12 16:59:56
33	01101105	A6-03-11-03	6	无任务	 	api	2024-01-12 16:59:09
34	01101201	A6-03-12-01	6	无任务	 	api	2024-01-12 17:00:20
35	01101203	A6-03-12-02	6	无任务	 	api	2024-01-12 16:59:32
36	01101205	A6-03-12-03	6	无任务	 	api	2024-01-12 16:58:46

```


```python
7号 16:39分发车 24个料箱
```


```python
17:07全部拉到
```


```python
#
AGV货位
货位
工作台号
状态
周转箱
更新用户
更新时间
4	01101401	A7-01-02-01	7	周转箱到位	2A-032657	api	2024-01-12 16:57:02
5	01101403	A7-01-02-02	7	周转箱到位	2A-028411	api	2024-01-12 16:48:22
6	01101405	A7-01-02-03	7	周转箱到位	2A-021980	api	2024-01-12 17:04:55
7	01101501	A7-01-03-01	7	周转箱到位	2A-020380	api	2024-01-12 16:57:59
8	01101503	A7-01-03-02	7	周转箱到位	2A-019653	api	2024-01-12 16:58:46
9	01101505	A7-01-03-03	7	周转箱到位	2A-019453	api	2024-01-12 16:43:12
10	01101601	A7-01-04-01	7	周转箱到位	2A-018769	api	2024-01-12 16:54:02
11	01101603	A7-01-04-02	7	周转箱到位	2A-018497	api	2024-01-12 16:46:31
12	01101605	A7-01-04-03	7	周转箱到位	2A-015516	api	2024-01-12 16:47:23
13	01101701	A7-02-05-01	7	周转箱到位	2A-013323	api	2024-01-12 16:48:27
14	01101703	A7-02-05-02	7	周转箱到位	2A-012939	api	2024-01-12 16:48:48
15	01101705	A7-02-05-03	7	周转箱到位	2A-011571	api	2024-01-12 16:54:46
16	01101801	A7-02-06-01	7	周转箱到位	2A-011296	api	2024-01-12 17:07:11
17	01101803	A7-02-06-02	7	周转箱到位	2A-010162	api	2024-01-12 16:49:30
18	01101805	A7-02-06-03	7	周转箱到位	2A-009351	api	2024-01-12 16:49:11
19	01101901	A7-02-07-01	7	周转箱到位	2A-009303	api	2024-01-12 16:56:28
20	01101903	A7-02-07-02	7	周转箱到位	2A-008445	api	2024-01-12 16:57:09
21	01101905	A7-02-07-03	7	周转箱到位	2A-006940	api	2024-01-12 16:43:36
22	01102001	A7-02-08-01	7	周转箱到位	2A-006165	api	2024-01-12 16:53:42
23	01102003	A7-02-08-02	7	周转箱到位	2A-001117	api	2024-01-12 16:44:29
24	01102005	A7-02-08-03	7	周转箱到位	2A-033467	api	2024-01-12 17:03:03
```

# 0115


```python
所提到的AGV（自动引导车）状态和员工关于AGV效率的反馈，这里有一个建议的报告结构和故事线：

1. **引言和背景**：
   - 简要介绍AGV在您的工作环境中的作用。
   - 概述当前AGV系统的运行情况，包括其重要性和任何已知的挑战或问题。

2. **AGV状态分析**：
   - 描述AGV的不同状态（如开机、关机、运行任务、充电、等待任务、故障异常等）。
   - 阐明这些状态如何影响AGV的总体效率和性能。

3. **员工反馈汇总**：
   - 提供上架人员和提货人员对AGV效率的不同观点。
   - 分析为什么会出现这种观点差异，可能包括硬件、软件、人力、流程等方面的原因。

4. **问题识别和分析**：
   - 根据AGV状态和员工反馈，识别关键问题。例如，某些站台的AGV性能不符合设计标准，或者设备续航能力不足等。
   - 对每个问题进行深入分析，探讨其对操作效率的影响。

5. **解决方案和建议**：
   - 针对识别的问题提出具体的解决方案。
   - 这些方案可能包括改进AGV性能、调整调度逻辑、优化通信系统、改进人机协作流程等。

6. **结论**：
   - 总结报告的主要发现和建议。
   - 强调采取这些措施将如何改善AGV的效率和整体运营性能。

在撰写报告时，使用数据和实际案例来支撑您的论点将非常有效。确保内容既具体又有针对性，同时提供清晰的逻辑链条，以便读者能够轻松跟随您的思路。此外，视觉辅助工具，如流程图和图表，也可以帮助清晰地传达复杂的信息。
```

# 0116


```python
# 生产性计算tt3

tt3res['prdcty']=3600/(tt3res['task_duration']/tt3res['task_count'])

tt3res2=tt3res.groupby(['allocated_robot_id'],as_index=False)[['task_duration','task_count']].sum()

### 算法1

agv_productivity_t3=(3600/(tt3res2['task_duration'].sum()/tt3res2['task_count'].sum()))
agv_count_t3=tt3res2['allocated_robot_id'].count()

print(f"平均每台AGV效率：{agv_productivity_t3:.1f}个料盒/小时, 共{agv_count_t3:.0f}台AGV小车参与作业。\nAGV整体产能：{agv_productivity_t3*agv_count_t3/2:.1f}个料盒/小时")

### 算法2

##### 1. 先算每辆车的生产性

tt3res2['prdcty']=3600/(tt3res2['task_duration']/tt3res2['task_count'])

##### 2. AGV的生产性求和

tt3res2['prdcty'].sum()/2

这两者算法的差异在哪里
```


```python
在这个例子中，提到的两个算法用于计算自动引导车（AGV）的生产效率，但它们采用不同的方法来得出结论。让我们分析一下每种算法的核心差异：

### 算法1
1. **计算整体平均效率**：首先计算所有AGV的总任务持续时间和总任务数，然后用这些总数来计算平均效率。
2. **平均每台AGV效率**：计算出的是所有AGV的平均效率（个料盒/小时）。
3. **AGV数量**：确定参与的AGV小车数量。
4. **AGV整体产能**：将平均效率乘以AGV数量的一半，得出整体产能（个料盒/小时）。

### 算法2
1. **计算每辆车的生产性**：首先，为每辆AGV分别计算其生产性。
2. **求和**：然后，将所有AGV的生产性相加。
3. **整体产能**：将生产性总和除以2，得出整体产能（个料盒/小时）。

### 差异
- **计算顺序**：算法1先计算整体平均，然后乘以AGV数量的一半；算法2先计算每辆车的生产性，然后将这些数值相加并除以2。
- **平均与个别**：算法1使用的是所有AGV的平均效率，而算法2是基于每辆车的具体生产性。
- **最终产能的计算**：在算法1中，整体产能是基于平均效率和AGV数量的乘积；在算法2中，是所有个别效率的总和的一半。

总结来说，这两种算法在处理数据的角度和计算最终产能的方法上存在差异。
算法1更侧重于平均效率，
而算法2更注重每辆车的个别表现。选择哪种算法取决于你希望强调的是整体平均表现还是个别AGV的具体表现。
```


```python
当您想计算AGV的整体效率时，选择合适的算法取决于您想要强调的是整体效率还是个体效率。让我们来比较一下您提供的两种算法：

### 算法1（整体平均效率）
- **核心逻辑**：计算所有AGV的总任务持续时间和总任务数量，然后用这些总数来计算平均效率。
- **优点**：简单，直观，提供了整个系统的一般表现。
- **缺点**：可能掩盖了个别AGV之间的性能差异。

### 算法2（个体生产性求和）
- **核心逻辑**：首先为每辆AGV计算其生产性，然后将这些数值求和并除以2。
- **优点**：提供了更详细的信息，可以看到每辆AGV的表现，有助于发现某些AGV的特别表现（无论好坏）。
- **缺点**：计算更复杂，如果AGV的数量很多，分析每一辆车可能并不实用。

### 选择建议
- 如果您的目标是获得整个系统的一般表现概览，**算法1**更合适。
- 如果您想了解每辆AGV的具体表现，并且对于性能差异感兴趣，**算法2**可能更适合。

此外，对于AGV服务多个站点的情况，您需要决定是否考虑所有任务还是只关注特定站点的任务。如果AGV在不同站点之间的表现差异很大，可能需要单独分析每个站点的数据。如果AGV的表现大体一致，那么使用整体数据可能就足够了。

最后，您提到的将`prdcty`总和除以2的方法（在算法2中）可能需要进一步的解释或理由，这取

决于为什么要除以2。这可能是为了调整某些特定的业务规则或假设，但如果没有具体的理由，这个操作可能不适用于所有情况。

综上所述，选择算法时，您应该考虑您的具体需求和数据的特点，以及您希望从分析中得到的信息类型。
```


```python
我想计算的是某个站台的效率。我觉得应该把相关站台所有的时间和量都加起来，然后除一下。这样对吗？会遇到时间重叠的问题吗？
```


```python
如果您想计算某个特定站台的效率，确实可以将该站台所有相关任务的总时间和总任务量加起来，然后进行计算。这种方法简单且直观，能够给出该站台整体效率的一个大致估计。但是，您提到的时间重叠问题是一个值得注意的点。这里有几个考虑因素：

### 1. 时间重叠问题
- 如果多个AGV可以同时在该站台工作，那么单纯地将所有任务的时间相加可能会高估实际花费的时间。在这种情况下，您需要考虑并行任务的时间。
- 如果AGV在该站台的工作是串行的（一次只能有一辆AGV工作），那么直接相加总时间是合理的。

### 2. 如何处理时间重叠
- **并行任务**: 如果AGV的任务可以并行进行，您需要计算的是在该站台上的总工作时间（即从第一个任务开始到最后一个任务结束的总时间），而不是单纯将所有任务的时间相加。
- **时间窗口分析**: 可以考虑使用时间窗口（如每小时或每天）来分析站台的效率。这样，您可以更准确地计算在给定时间内完成的任务量。

### 3. 计算方法
- **总效率**: 总效率可以通过将总任务量除以总时间（考虑并行任务）来计算。
- **平均效率**: 还可以考虑计算平均效率，例如，每小时或每班次的平均任务量。

### 结论
根据您的需求和数据的具体情况，选择合适的计算方法。如果可能，考虑并行任务的时间重叠，并选择合适的时间单位（如小时或班次）来计算平均效率，这样可以得到更准确、更有意义的效率指标。
```

# 站台效率无法通过AGV的时间轴去进行统计，因为会遇到一个站台多辆车在搬运料盒的情况。实际效率会被扩大
## # 应该通过时间窗口分析来展示


```python
# 废弃代码示例
```


```python
def calculate_agv_efficiency(tt3, tt3res, workstation):
    # 筛选特定工作站的任务
    station_task = list(tt3.loc[tt3['workstation'] == workstation]['agv_task_list'])
    tt3res_filtered = tt3res.loc[tt3res['agv_task_list'].isin(station_task)]

    # 分组并计算每台AGV的任务持续时间和任务数量
    tt3res_grouped = tt3res_filtered.groupby(['allocated_robot_id'], as_index=False)[['task_duration', 'task_count']].sum()

    # 计算平均效率和AGV数量
    agv_productivity = 3600 / (tt3res_grouped['task_duration'].sum() / tt3res_grouped['task_count'].sum())
    agv_count = tt3res_grouped['allocated_robot_id'].count()

    # 计算整体产能
    total_capacity = agv_productivity * agv_count / 2

    # 计算总耗时
    total_hours = (tt3res_filtered['task_duration'].sum() / 3600)

    return {
        'average_efficiency': agv_productivity,
        'agv_count': agv_count,
        'total_capacity': total_capacity,
        'total_hours': total_hours
    }
```


```python
# 使用函数
result = calculate_agv_efficiency(tt3, tt3res, 1)
print(f"平均每台AGV效率：{result['average_efficiency']:.1f}个料盒/小时, 共{result['agv_count']}台AGV小车参与作业。\nAGV整体产能：{result['total_capacity']:.1f}个料盒/小时")
print(f"共花费：{result['total_hours']:.1f}个小时")
```

# 0117 


```python
AGV 压测效率与实际效率的关联和意义
```


```python
AGV（自动引导车）的压力测试通常是为了评估AGV在极限操作条件下的性能和效率。这种测试可以揭示AGV在高负载、连续操作或在特定复杂环境中的表现。在此背景下，“效率”通常指的是几个不同的方面：

1. **搬运效率**：指AGV在单位时间内完成的任务数量，例如每小时搬运的料盒数。

2. **能源效率**：指AGV在执行任务过程中的能源消耗情况，如每完成一个任务所消耗的电量。

3. **路径效率**：指AGV在移动过程中选择的路径是否最优，以及它们在避免障碍物或选择最短路径方面的能力。

4. **响应时间**：从接收任务指令到开始执行任务的时间。

### 实际应用中的效率
在实际应用中，AGV的效率可能会因多种因素而有所不同，包括：

- **工作环境**：不同的工作环境（如仓库布局、地面条件、交通流量等）会影响AGV的效率。
- **任务类型**：不同的任务（如搬运、拣选、上下架等）可能需要不同的时间和能量消耗。
- **系统集成**：AGV系统与仓库管理系统的集成程度也会影响效率。
- **维护和管理**：良好的维护和管理可以提高AGV的运行效率。

### 目标设定
设定AGV效率目标时，应考虑以下因素：

- **行业基准**：研究同行业中使用AGV的其他公司的效率标准。
- **历史数据**：分析您公司过去的AGV效率数据，设定切实可行的提升目标。
- **压力测试结果**：使用压力测试结果作为极限性能的参考标准。
- **改进空间**：根据您的运营流程和AGV技术的改进空间来设定目标。
- **可持续性**：确保设定的目标在长期内既可达成又可持续。

综合考虑这些因素，您可以设定一个既有挑战性又现实可行的效率目标。这个目标应当是动态的，根据业务需求和技术进步进行调整。
```

# 0121-0122


```python
我最近在分析AGV的效率。现在想着要如何向其他人说明。现在有几个课题
第一个是如何区别AGV效率的算法，哪种比较好，或者说各自有什么优劣。
1. 选择某一个时间段的作业量，作为设备的效率
2. 把所有的完成量和作业时间都合计起来，（去掉重复部分）作为设备的效率。
3. 用时间窗口的方法，得到设备某个时间段的产量。
第二个课题是怎样的目标比较合适。
```


```python
对于你的第一个课题，关于如何区别AGV效率的算法以及它们的优劣，这是一个重要的问题，因为不同的算法可能适用于不同的情况。以下是针对不同算法的优劣势分析：

1. **选择某一个时间段的作业量作为设备的效率：**
   - **优点：** 这个方法简单明了，容易理解。你可以快速计算出设备在特定时间段内完成的任务数量。
   - **缺点：** 这种方法可能会忽略设备的稳定性和连续性。如果在某个时间段内设备运行非常快，但在其他时间段内运行非常慢，这种方法可能无法捕捉到整体性能的波动。

2. **把所有的完成量和作业时间都合计起来，去掉重复部分，作为设备的效率：**
   - **优点：** 这种方法考虑了设备的连续性和稳定性。它可以反映设备在整个时间段内的平均性能。
   - **缺点：** 需要更多的数据和计算，可能不够直观。此外，去除重复部分可能需要定义清楚的规则。

3. **用时间窗口的方法，得到设备某个时间段的产量：**
   - **优点：** 这种方法可以捕捉到设备性能的变化趋势。它允许你在不同的时间段内比较设备的表现。
   - **缺点：** 需要定义合适的时间窗口大小，过大或过小的窗口可能会导致信息丢失或噪音。

对于第二个课题，关于选择合适的目标来比较AGV的效率，这取决于你的具体需求和业务目标。以下是一些可能的目标：

1. **最大化产量：** 如果你的主要关注是提高产量，那么你可以比较不同算法在相同时间段内的总产量。

2. **最小化能源消耗：** 如果节能是你的重点，你可以考虑比较不同算法在完成相同任务时所需的能源消耗。

3. **最小化等待时间：** 如果你想减少任务等待时间，你可以比较不同算法在任务分配和执行方面的效率。

4. **最小化故障率：** 如果设备可靠性很重要，你可以比较不同算法在减少设备故障率和维护需求方面的效果。

5. **最小化成本：** 考虑成本效益，比较不同算法在提高效率的同时是否会增加额外的成本。

选择合适的目标取决于你的具体情况和优先级。你可以根据你的业务需求来制定明确的性能指标，并使用这些指标来比较不同的AGV效率算法。
```


```python
AGV（自动引导车辆）效率的算法可以从多个角度来衡量，不同的方法反映了不同的生产管理侧重点，以下是对你提出的三种算法的解析：

1. **选择某一个时间段的作业量作为设备的效率**：
   - **优点**：简单易行，容易理解，适用于快速评估生产峰值能力。
   - **缺点**：可能忽略了周期性的生产波动，且在作业量较少的时间段内无法准确反映设备的实际效率。

2. **把所有的完成量和作业时间都合计起来（去掉重复部分）作为设备的效率**：
   - **优点**：提供长期平均效率指标，较好地反映了设备的整体性能。
   - **缺点**：处理复杂，如果作业时间重叠不易理清，可能不易于发现短期的效率问题。

3. **用时间窗口的方法得到设备某个时间段的产量**：
   - **优点**：能够平衡及时性与全面性，通过滑动时间窗口可以观察到效率随时间的动态变化。
   - **缺点**：所选时间窗口的长度会影响效率的评估指标，太短可能造成评估的波动性太大，太长则可能因响应迟缓而不能及时反映问题。

对于第二个课题，合适的目标设置应考虑以下几个方面：

1. **目标可实现性**：目标应当是挑战性的，但又要确保在当前的生产条件下是可以实现的。

2. **目标相关性**：目标要与企业的总体战略和长期目标相关联。

3. **目标的具体性和明确性**：有明确的数值目标和时间框架，便于员工理解和努力达到。

4. **目标的可衡量性**：目标需有明确的评价标准，便于度量进度和结果。

5. **目标的灵活性**：在一定程度上，目标需要能够适应变化的生产情况和市场需求。

设定目标时还需考虑产能限制、劳动力约束、物料供应稳定性等真实生产条件。总体来说，一个合适的目标应该能激励团队，提高生产效率，并最终增加企业竞争力。
```

这些算法在学术上可能被称为AGV效率评估方法或者AGV性能比较算法。简单理解的描述可以是“时间段作业量法”、“整体作业量法”和“时间窗口产量法”。

在PPT中，你可以将重点放在对这些算法的简明解释和它们的优缺点上。你可以通过比较不同算法在特定情况下的表现，进行故事化的说明。例如，你可以选择一个实际案例，描述该案例中AGV的运作情况，并对比不同算法对于该案例的适用性和效果。通过具体的案例和对比分析，可以更生动地展示不同算法的特点和应用情境。

另外，你还可以结合图表和数据来展示不同算法的结果，以及对应的目标比较，使听众更直观地理解各种算法的优劣势。最后，你可以给出针对不同算法的性能指标，帮助听众理解如何根据特定目标选择合适的算法。


```python
对于这些算法，没有特定的学术称呼。它们可以被描述为简单的效率计算方法，用于区别AGV的性能。

在PPT中说明这些内容时，可以按照以下故事线来组织：

引入问题： 开始时，介绍AGV效率的重要性以及为什么需要区分不同的算法来评估AGV的性能。

介绍不同的算法： 依次介绍第一个算法（选择某一个时间段的作业量），第二个算法（把所有的完成量和作业时间都合计起来，去掉重复部分），以及第三个算法（用时间窗口的方法，得到设备某个时间段的产量）。对每个算法，可以简要描述其原理和计算步骤。

分析优劣势： 对每个算法，详细分析其优点和缺点。可以使用比较表格或图表来清晰地展示它们之间的差异。

确定合适的目标： 接下来，介绍如何选择合适的目标来比较AGV的效率。列举不同的目标，如最大化产量、最小化能源消耗、最小化等待时间等，并解释每个目标的重要性。

总结和建议： 最后，总结不同算法的优劣势，以及选择合适的目标的重要性。根据具体情况，给出建议，例如根据业务需求选择最适合的算法和目标。

在PPT中，重点应该放在不同算法的优劣势分析和选择合适的目标上。使用清晰的图表和图像来支持你的论述，并确保故事线逻辑清晰，易于理解。
```


```python
这些算法在物流和自动化领域通常涉及到生产效率、任务调度和资源利用等方面。一些学术的称呼可能包括：

生产效率算法： 主要关注如何最大化设备在一定时间内的产量。
任务调度算法： 考虑如何有效地分配和调度任务，以提高设备利用率。
资源优化算法： 关注如何最大程度地利用设备资源，例如时间和能源。
对于PPT的制作，你可以按照以下故事线来呈现你的内容：

第一部分：问题陈述

简要介绍AGV（自动导引车）及其在物流中的应用。
引入问题：如何评估AGV的效率，选择合适的算法？
第二部分：算法比较

详细介绍三种算法：选择某一时间段的作业量、合计完成量和作业时间、时间窗口方法。
使用图表和示意图展示算法的运作方式。
第三部分：优劣势分析

对每种算法进行优劣势分析，强调它们的适用场景和局限性。
强调在实际应用中可能遇到的挑战。
第四部分：目标选择与比较

提出不同的目标，如最大化产量、最小化能源消耗等。
分析每个目标对算法的影响，以及在实现这些目标时的考虑因素。
第五部分：学术角度与简单形容

简要介绍学术上的称呼，例如生产效率算法、任务调度算法等。
使用简单易懂的语言解释这些算法，确保观众能够理解核心概念。
第六部分：结论与建议

总结各算法的特点，根据业务需求给出建议。
强调在实际应用中选择适合场景的算法的重要性。
通过这样的故事线，你可以清晰地向观众传达关键信息，使他们更容易理解AGV效率算法的比较和选择。
```

# 0125


```python
小高想做事业化，是独立科室好，还是暂时挂在硬件开发下面好。
```


```python
首先，暂时的确是个折中的方法
1. 推广的产品，少不了跟开发部门打交道。
2. 但要明确跟开发的工作边界和责任范围。

要想独立出一个section。我个人觉得的前提条件（当然不是必须，才能分开的意思）
1. 售卖的东西达到一定的规模市场
2. 种类涉及领域变多。(比如：系统、小工具、或其他的产品)
3. 因市场变大后，必须具备的功能
   a. 市场调研
   b. 风险管理
   c. 产权保护
```


```python
根据您提供的情况，将小高从现在的课移动到老周下面，以便专注于事业化的方向，听起来是为了更好地整合资源和专业技能。
您提到的折中方法可能确实是当前的最佳选择，特别是如果小高的工作确实需要与硬件开发紧密结合。以下是一些建议和考虑因素，希望对您的决策有所帮助：

1. **资源配置**：确保在事业化过程中，小高可以获得所需的资源和支持，包括人力、资金、技术等，以确保可以顺利推进。

2. **团队协作**：考虑如何促进小高与开发部门的协作，以及小高团队与其他团队（如市场、销售、客服等）的协作，确保流程顺畅，沟通无障碍。

3. **市场调研**：进行市场调研，了解目标客户的需求，确保所推动的产品或服务能够满足市场需求，并有足够的竞争力。

4. **业务规划**：制定清晰的业务规划，包括短期和长期目标，业务扩展策略，以及如何评估业务表现。

5. **风险管理**：识别潜在的风险，如市场变化、技术更新换代、竞争对手的动向等，并制定应对策略。

6. **绩效评估**：建立绩效评估机制，定期检查业务进展与目标的匹配程度，并根据评估结果调整策略。

7. **知识产权保护**：确保在产品开发和商业化过程中，知识产权得到合理保护，避免未来可能出现的法律纠纷。

8. **培训和发展**：小高及其团队可能需要针对事业化过程中遇到的新挑战进行培训，包括业务发展、客户关系管理、市场营销等方面的知识和技能。

最后，确保小高与老周之间有一个清晰的工作分界，明确职责和期望，以保证工作有效进行。在考虑这些因素的基础上，您可以进一步优化小高的职位调整和事业化进程的推动。
```


```python
我接下来要负责一个部门，这个部门主要做的业务是软件开发、（海外软件的运维）,数据分析、报表制作、予算的管理。
因为已经有了一个物流企划部。那我应该怎么起这个部门名字比较好
```


```python
考虑到您即将负责的部门主要负责软件开发、海外软运维、数据分析、报表制作以及预算管理等工作，可以选择一个既具体又能体现部门职能的名称。以下是一些建议名称：

1. 信息技术与数据分析部（IT & Data Analysis Department）
2. 软件开发与服务管理部（Software Development & Service Management Department）
3. 业务智能与技术支持部（Business Intelligence & Technical Support Department）
4. 数字解决方案与运维部（Digital Solutions & Operations Department）
5. 技术发展与资源管理部（Technology Development & Resource Management Department）

选择部门名称时，您可以考虑公司的命名惯例、组织文化以及部门的战略目标。确保名称简洁、直观且能准确反映部门的核心职能。同时，如果公司有可能进行国际业务，选择一个容易理解且在多种语言环境中都显得专业的名称也是一个不错的选择。
```


```python
当然可以。以下是一些更精简的部门名称建议：

1. 技术与数据部（Tech & Data Department）
2. 软件服务部（Software Services Department）
3. 业务分析部（Business Analysis Department）
4. 数字运营部（Digital Operations Department）
5. IT管理部（IT Management Department）

您可以根据部门的核心职能和公司的整体架构来选择最合适的名称。简洁的名称便于记忆和沟通，同时也能够清晰地传达部门的主要职责。
```


```python
了解到您的部门属于物流领域，并且涉及到硬件设备（自动化）、软件系统以及数据分析，那么部门名称可以更多地体现这些元素。根据这些信息，以下是一些建议的部门名称：

1. 物流技术与分析部（Logistics Technology & Analysis Department）
2. 自动化系统与数据部（Automation Systems & Data Department）
3. 智能物流解决方案部（Smart Logistics Solutions Department）
4. 物流IT支持部（Logistics IT Support Department）
5. 运营技术与智能分析部（Operational Tech & Intelligence Department）

选择部门名称时，考虑到与“模式展开部”有所关联，您可以选择一个与母部门名称相协调，同时能够反映您部门职能的名称。这样既能保持上下部门之间的逻辑关联性，又能准确传达您部门的特色和职责。
```


```python
模式企划部（课）
模式运营部（课）

数字运营部
数字服务部
技术数据部（课）有点偏IS的体系了

```


```python
模式展开部
模式企划课
模式数据课

```


```python
开发运维课
开发运维部
基础架构课
基础企划课
AI模型开发部
IT基础架构部
电商数据管理课
企业数据管理课
数据管理部
AI研究开发课

```


```python
<承下启上> 
```


```python
1.广州 重复使用的料箱的返回规则是什么
问黄工

2. 背篓利用率的任务量的关系-相关性

3. 料箱重叠率
```


```python
生产性目标怎么设
```


```python
1.压测值
2.稳定期、饱和器的稳定值
```


```python
该做的都做了，压测值是多少，稳定值是多少
```


```python
#0131
```


```python
import numpy as np
import matplotlib.pyplot as plt

def plot_rose(k, num_points=1000):
    """
    绘制玫瑰线的函数。
    
    参数:
    - k: 控制花瓣数量的参数。
    - num_points: 绘制曲线时使用的点的数量。
    """
    theta = np.linspace(0, 2*np.pi, num_points)
    r = np.cos(k * theta)  # 你可以改为 np.sin(k * theta) 试试看有什么不同
    
    plt.figure(figsize=(6,6))
    plt.polar(theta, r)  # 使用极坐标绘图
    plt.title(f"Rose curve with k={k}")
    plt.show()
```


```python
# 画出4瓣的花
plot_rose(k=4)
```


    
![png](output_84_0.png)
    



```python
# 画出5瓣的花
plot_rose(k=5)
```


    
![png](output_85_0.png)
    



    
![png](output_85_1.png)
    

