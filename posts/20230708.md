```python
TheB.AI Beta
https://docs.google.com/forms/d/e/1FAIpQLSdcMy-v3VhPJG0ubM2UpKz9GNxGzQmvypNacuv9kXd3BMgOQQ/viewform
```


```python
# [图灵程序设计丛书].统计思维：程序员数学之概率统计【neikuw.com】


Discrete uniform distribution
https://en.wikipedia.org/wiki/Discrete_uniform_distribution
```


      File "<ipython-input-1-3f408a5ca781>", line 2
        https://en.wikipedia.org/wiki/Discrete_uniform_distribution
              ^
    SyntaxError: invalid syntax
    



```python
PMF（Probability Mass Function，概率质量函数）
CDF（Cumulative Distribution Function，累积分布函数）
```


```python
用random.random 生成1000 个数字，画出它们的PMF 和CDF。是
否能判断它们是均匀分布？
```


```python
import random
import numpy as np
import matplotlib.pyplot as plt

# 生成1000个随机数
random_numbers = [random.random() for _ in range(1000)]

# 绘制PMF
plt.hist(random_numbers, bins=20, density=True, alpha=0.5)
plt.xlabel('Value')
plt.ylabel('Probability')
plt.title('Probability Mass Function (PMF)')
plt.show()

# 绘制CDF
sorted_numbers = np.sort(random_numbers)
cdf = np.arange(len(sorted_numbers)) / float(len(sorted_numbers))
plt.plot(sorted_numbers, cdf)
plt.xlabel('Value')
plt.ylabel('Cumulative Probability')
plt.title('Cumulative Distribution Function (CDF)')
plt.show()

```


    
![png](output_4_0.png)
    



    
![png](output_4_1.png)
    



```python
# 计算中位数
length = len(sorted_numbers)
if length % 2 == 0:
    median = (sorted_numbers[length // 2] + sorted_numbers[length // 2 - 1]) / 2
else:
    median = sorted_numbers[length // 2]

print("Median:", median)
```

    Median: 0.4888032454751554
    


```python
import pandas as pd
```


```python
df=pd.DataFrame(sorted_numbers)
```


```python
df.median()
```




    0    0.488803
    dtype: float64




```python
df.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1000.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.497206</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.289978</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.001276</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.248541</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.488803</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.748390</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.999710</td>
    </tr>
  </tbody>
</table>
</div>




```python
df.describe().index
```




    Index(['count', 'mean', 'std', 'min', '25%', '50%', '75%', 'max'], dtype='object')




```python
df.describe().loc['50%']
```




    0    0.488803
    Name: 50%, dtype: float64




```python
#指数分布和帕累托分布
```


```python
指数分布和帕累托分布是两种不同的概率分布模型，具有不同的特征和应用领域。

1. 指数分布（Exponential Distribution）：
指数分布是一种连续概率分布，常用于描述随机事件发生的时间间隔。它具有单峰、正偏态（右偏）的特点。指数分布的概率密度函数（PDF）为：

f(x) = λ * exp(-λx)

其中，λ是分布的参数，表示单位时间内事件发生的平均次数。指数分布的期望值为 1/λ，方差为 1/(λ^2)。

2. 帕累托分布（Pareto Distribution）：
帕累托分布是一种长尾分布，也称为幂律分布。它通常用于描述在一个系统中，少数个体占据了大部分资源或事件发生的现象。帕累托分布的概率密度函数（PDF）为：

f(x) = (α * xₘᵃ) / x^(α+1)

其中，α和xₘ是分布的参数。α决定了分布的形状，而xₘ表示最小非零观测值。帕累托分布的期望值存在当且仅当α>1时，方差也存在当且仅当α>2时。

总结：
指数分布和帕累托分布是两种不同类型的概率分布。指数分布适用于描述事件发生的时间间隔，具有正偏态特征；而帕累托分布适用于描述资源分配或事件发生中的不均衡现象，具有长尾分布的特点。
```


```python

```


```python
抛100 次硬币，应该可以得到50 次正面朝上，但恰好50 次正面朝上
的概率是多少？
```


```python
要计算恰好出现50次正面朝上的概率，我们可以使用二项分布来求解。二项分布描述了在一系列独立的伯努利试验中成功事件（正面朝上）发生的次数。

在这个问题中，每次抛硬币都是一个独立的伯努利试验，成功事件是硬币正面朝上。问题要求出现50次正面朝上，因此我们可以将概率参数设置为0.5。

以下是一个Python代码示例，使用scipy库中的二项分布函数来计算恰好出现50次正面朝上的概率：

```python
from scipy.stats import binom

n = 100  # 抛硬币的次数
p = 0.5  # 正面朝上的概率

# 使用二项分布计算恰好出现50次正面朝上的概率
probability = binom.pmf(50, n, p)

print("恰好出现50次正面朝上的概率：", probability)
```

运行以上代码，输出结果将给出恰好出现50次正面朝上的概率。请注意，这是一个近似值，可能会存在舍入误差。

希望对你有所帮助！
```


```python
这个问题可以使用二项分布来解决。在抛硬币的情况下，每次试验有两个可能结果：正面朝上或反面朝上。我们知道，在一次独立的硬币投掷中，正面朝上和反面朝上的概率都是1/2。

现在考虑进行100次硬币投掷，我们想知道其中恰好有50次正面朝上的概率。根据二项分布的公式，可以表示为：

P(X = k) = C(n, k) * p^k * (1-p)^(n-k)

其中，P(X = k) 是恰好有k次正面朝上的概率，n 是投掷次数，p 是正面朝上的概率（1/2），C(n, k) 是组合数，表示从n次中选择k次的方式。

对于这个问题，n = 100，k = 50，p = 1/2，将这些值代入上述公式，可以得到：

P(X = 50) = C(100, 50) * (1/2)^50 * (1 - 1/2)^(100-50)

计算这个表达式，即可得到恰好有50次正面朝上的概率。
```


```python
from scipy.stats import binom

n = 100  # 抛硬币的次数
p = 0.5  # 正面朝上的概率

# 使用二项分布计算恰好出现50次正面朝上的概率
probability = binom.pmf(50, n, p)

print("恰好出现50次正面朝上的概率：", probability)
```

    恰好出现50次正面朝上的概率： 0.07958923738717888
    


```python
# 计算P(x=50)
def calculate_p(x):
    # 这里假设有一个概率分布函数f(x)，根据具体情况进行修改
    # 假设 f(x) = 1/x^2
    f_x = 1 / (x**2)
    
    # 计算总体积分
    total_integral = 0
    for i in range(1, x+1):
        total_integral += f_x
    
    # 计算概率
    p_x = f_x / total_integral
    return p_x

# 调用函数计算P(x=50)
p_50 = calculate_p(50)
print("P(x=50) =", p_50)


# 计算C(100, 50)
def calculate_combination(n, k):
    # 使用math库中的组合函数comb来计算组合数
    from math import comb
    c = comb(n, k)
    return c

# 调用函数计算C(100, 50)
c_100_50 = calculate_combination(100, 50)
print("C(100, 50) =", c_100_50)
```

    P(x=50) = 0.02
    C(100, 50) = 100891344545564193334812497256
    


```python
calculate_combination(5, 3)
```




    10




```python
calculate_p(4)
```




    0.25




```python
from scipy.stats import binom

def calculate_p(x):
    n = 100  # 抛硬币的次数
    p = 0.5  # 正面朝上的概率
    
    # 使用二项分布计算恰好出现 x 次正面朝上的概率
    probability = binom.pmf(x, n, p)
    
    return probability

# 调用函数计算P(x=50)
p_50 = calculate_p(50)
print("P(x=50) =", p_50)

```

    P(x=50) = 0.07958923738717888
    


```python
import math

def permutation(n, m):
    return math.factorial(n) / math.factorial(n - m)
```


```python
print(permutation(5, 3))  # 输出结果：60
print(permutation(5, 2))  # 输出结果：20
```

    60.0
    20.0
    

神枪手谬误（The Sharpshooter Fallacy）是一种逻辑谬误，也称为牧师命中错误。该谬误描述了对数据进行选择性分析时的错误推理。

该谬误的基本情景是，有一个射击目标的牧师，他将子弹射向墙壁，并随机地画上一个目标圆圈，然后宣布自己是一个出色的神枪手。牧师只展示了那些击中目标的部分，并忽略了其他所有未命中的部分。然后，他声称自己精确预测了射击位置，因此是个天才的神枪手。

然而，这是一个谬误，因为牧师在射击之前并没有事先确定圆圈的位置。相反，他根据已经射中的目标来选择目标圆圈。这意味着他的成功只是由于纯粹的偶然性，而不是他的技能或准确度。

神枪手谬误的教训是，在数据分析和研究中，我们必须小心避免选择性地关注某些结果，而忽略掉其他可能的结果。我们应该考虑到随机性和抽样误差等因素，以更准确地评估任何观察结果的可靠性和相关性。


```python
import numpy as np
import matplotlib.pyplot as plt

# 生成左偏分布的随机数据
sample_size = 1000
mean = 50  # 平均值
standard_deviation = 10  # 标准差
skewness = -1.5  # 偏斜度

data = np.random.normal(loc=mean, scale=standard_deviation, size=sample_size)
data = np.power(data, skewness)

# 绘制直方图
plt.hist(data, bins=30, density=True, alpha=0.7)
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.title('Left-skewed Distribution')
plt.show()

```


    
![png](output_26_0.png)
    



```python
#左偏的分布的均值就会小于中位数
```


```python
data.mean()
```




    1.6572389461936152




```python
import numpy as np

median = np.median(data)
print("Median:", median)
```

    Median: 1.6615410363907581
    


```python
# import numpy as np
import matplotlib.pyplot as plt

# 生成右偏分布的随机数据
sample_size = 1000
mean = 50  # 平均值
standard_deviation = 10  # 标准差
skewness = 0.13  # 偏斜度

data = np.random.normal(loc=mean, scale=standard_deviation, size=sample_size)
data = np.power(data, skewness)

# 绘制直方图
plt.hist(data, bins=30, density=True, alpha=0.7)
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.title('Right-skewed Distribution')
plt.show()

```


    
![png](output_30_0.png)
    


# 0704 DragGAN


```python
DragGAN
#https://github.com/XingangPan/DragGAN
#windows下的即用环境，但没测试过。
https://github.com/zhaoyun0071/DragGAN-Windows-GUI
    
动画换脸
https://github.com/s0md3v/roop
    
https://github.com/zhaoyun0071/roop-windows-GUI
    
图片抠掉某些内容
https://github.com/zhaoyun0071/LAMA-Magic-Eraser-Windows    
    
AI作图
https://github.com/zhaoyun0071/Disco-Stable-Diffusion-Win-GUI
```


```python
https://github.com/zhaoyun0071/DragGAN-Windows-GUI
```

# Matplotlib中的示例图


```python
https://www.osgeo.cn/matplotlib/tutorials/introductory/sample_plots.html
```

# 0705 github教程集合


```python
https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-zh.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6
```

# 0710


```python
山前山后各有哀愁，有风无风都不自由。
人来人往各怀心事，有雨无雨皆为过往。
```


```python
track in time 你知道吗？

我认识“Track in Time”这个词组，但不确定你需要了解什么方面的信息。 “Track in Time”通常指跟踪时间或时间管理的技巧和方法，例如记录时间、优先级管理、计划和目标设置等。如果你有更具体的问题或需要更详细的信息，请告诉我，我会尽力回答。

一首曲子

当然，我可以为你创作一首曲子，但需要更多的信息来了解你需要什么类型的曲子。你是想听流行歌曲、摇滚、古典、爵士、电子音乐还是其他类型的曲子？你有任何特定的主题或情感想要表达吗？请告诉我更多的细节，我会尽力为你创作一首适合你的曲子。

track in time

如果你想让我为你创作一首关于时间管理的曲子，我可以尝试写一下歌词作为参考：

[Verse 1]
Tick-tock, the clock keeps ticking
My to-do list keeps growing
So many things I need to do
But where do I even start?

[Chorus]
Track in time, manage it right
Make the most of every day and night
Set your goals and prioritize
Track in time, make your life shine

[Verse 2]
Time is precious, it won't wait
Don't let it slip away
Plan ahead, stay focused
And you'll get it done today

[Chorus]
Track in time, manage it right
Make the most of every day and night
Set your goals and prioritize
Track in time, make your life shine

[Bridge]
You can't buy more time, it's true
So use it wisely, it's up to you
Track in time, you'll see the way
To make the most of every day

[Chorus]
Track in time, manage it right
Make the most of every day and night
Set your goals and prioritize
Track in time, make your life shine

[Outro]
Track in time, track in time
Make your life shine, make your life shine.

翻译一下用中文

当然，我可以为您翻译刚才创作的关于时间管理的歌曲歌词，以下是中文版：

[Verse 1]
滴答滴答，钟声不停
待办事项越来越多
有太多事情需要去做
但我该从哪里开始？

[Chorus]
追踪时间，管理得当
充分利用每个白天黑夜
设定目标，优先处理
追踪时间，让你的生命闪耀

[Verse 2]
时间很珍贵，它不会等待
不要让它溜走
提前计划，保持专注
你今天就可以完成任务

[Chorus]
追踪时间，管理得当
充分利用每个白天黑夜
设定目标，优先处理
追踪时间，让你的生命闪耀

[Bridge]
你不能买到更多的时间，这是真的
所以明智地使用它，取决于你自己
追踪时间，你会看到方向
充分利用每一天

[Chorus]
追踪时间，管理得当
充分利用每个白天黑夜
设定目标，优先处理
追踪时间，让你的生命闪耀

[Outro]
追踪时间，追踪时间
让你的生命闪耀，让你的生命闪耀。

[Verse 1] [Chorus] [Verse 2] [Bridge] [Chorus] [Outro] 是啥意思

这些术语是音乐歌曲的结构元素，用于描述歌曲中的不同部分。以下是每个术语的含义：

Verse 1：第一段歌词，通常在歌曲开始时出现，用于介绍歌曲的主题或情感。
Chorus：通常是歌曲最重要的部分，在歌曲的不同部分反复出现，是歌曲中最易记忆的部分。
Verse 2：第二段歌词，在第一段之后出现，通常用于表达更多的情感或细节。
Bridge：是一种歌曲中的过渡部分，通常出现在Chorus和Verse之间，用于连接两个部分并引出不同的情感或主题。
Outro：歌曲的结尾部分，通常是一个重复的Chorus或一个独立的乐器旋律，用于结束歌曲。
这些术语通常用于描述歌曲的结构和安排，以帮助歌曲作者和音乐制作人创建一首有组织和易于理解的歌曲。
```


```python
%lsmagic
```




    Available line magics:
    %alias  %alias_magic  %autoawait  %autocall  %automagic  %autosave  %bookmark  %cat  %cd  %clear  %colors  %conda  %config  %connect_info  %cp  %debug  %dhist  %dirs  %doctest_mode  %ed  %edit  %env  %gui  %hist  %history  %killbgscripts  %ldir  %less  %lf  %lk  %ll  %load  %load_ext  %loadpy  %logoff  %logon  %logstart  %logstate  %logstop  %ls  %lsmagic  %lx  %macro  %magic  %man  %matplotlib  %mkdir  %more  %mv  %notebook  %page  %pastebin  %pdb  %pdef  %pdoc  %pfile  %pinfo  %pinfo2  %pip  %popd  %pprint  %precision  %prun  %psearch  %psource  %pushd  %pwd  %pycat  %pylab  %qtconsole  %quickref  %recall  %rehashx  %reload_ext  %rep  %rerun  %reset  %reset_selective  %rm  %rmdir  %run  %save  %sc  %set_env  %store  %sx  %system  %tb  %time  %timeit  %unalias  %unload_ext  %who  %who_ls  %whos  %xdel  %xmode
    
    Available cell magics:
    %%!  %%HTML  %%SVG  %%bash  %%capture  %%debug  %%file  %%html  %%javascript  %%js  %%latex  %%markdown  %%perl  %%prun  %%pypy  %%python  %%python2  %%python3  %%ruby  %%script  %%sh  %%svg  %%sx  %%system  %%time  %%timeit  %%writefile
    
    Automagic is ON, % prefix IS NOT needed for line magics.




```python
%history
```

    %lsmagic
    %history
    


```python
%xmode
```

    Exception reporting mode: Verbose
    


```python
%time
对单个语句的执行时间进行计时。
%timeit
对单个语句的重复执行进行计时，以获得更高的准确度。
%prun
利用分析器运行代码。
%lprun
利用逐行分析器运行代码。
%memit
测量单个语句的内存使用。
%mprun
通过逐行的内存分析器运行代码。
```


```python
新题库-试卷下载
https://www.xintiku.com/kaojuan/nianji_chuer-diqu_25/
```


```python
# 书本太多，先留个档案
https://github.com/jsagreas/books/tree/main
```


```python
计划卖10000个商品，
计划中：
计划运费单价：A:0.32 B:0.44 C：2.22
计划运费单价均价：0.38
实际卖：
商品数：A:6720,B:1691 C：303
实际运费单价：A:0.27 B:0.36 C:1.45
实际实际单价均价：0.33
问：有多少是因为卖的量不足造成，有多少是因为商品原因造成。分别是什么
```

# 0724

1. 7月FC -旅费削减部分 - 已调整
2. 配送模型 - 已完成，交付
3. 7/20 dailyreport 制作品REC 计算逻辑验证 （3350REC）-张玲妹 -完成，等待回复
4. 数据同步延后，待验证
5. KPI数据制作工具，leadtime模块的后续bug修正-已完成

# 0724

1. 数据同步验证
2. BMM资料确认


```python
approaching(almost) any machine learning problem
```

# 0801


```python
1. 7月FC
  1. driver制作
  2. 人件费调整提醒(尤、张)
  3. 外包人员费用削减（孟 运费多少??）
2. KPI
  4. 在库保管会议 13:30-14:30
  5. MAGI数据下载
```


```python
会议纪要：
已明确的KPI图例如下：
 1. 在库保管状态监控（事业部别）
    *分成4种库位类型：PL、LL、普通、AGV
    Action：
        (1) 图例模板制作（4图）-顾
        (2) 4种库位与库位类型明细的关系-陈
             （AGV库位的抽取逻辑请告诉小陈）
        (3) 4种库位类型的最大保管量-张(文锋)、龚
 2. 在库周转率监控（商品分类别）
    Action:
        (1) 图例模板制作（1图）-顾
        (2) 商品分类定义明确：DS、低回转、中回转、高回转、新商品等-张(文锋)、龚
          *DS定义：采用SCM同一逻辑
        (3) 在库商品定义数据整理成需求，已连携UU整理成由SCM定期提供的方向推进。 -
遗留议题： 在库保管KPI考核的思考：从物流痛点出发、借鉴类似行业考核方法等。   
```


      File "<ipython-input-1-e5205c8bc62f>", line 1
        会议纪要：
            ^
    SyntaxError: invalid character in identifier
    


# 0803

1. 工时提交 OK
2. FC提交  ok
3. GKPI提交  ok
4. 在库保管 模板下发   ok 
5. 重量数据验证 ok  

8月大于5W费用（日常费用不计入）：
经费：
1.保险费(SHLG)：日本向け輸出保険料、 76.2K
2.修繕費(SHLG): NPS，timesheet等改修、60K
投资：
1. 新仓库：27,187K
   <1> 工程款12期 20,305K (已提交财务)
   <2> OP设备 6,148K
   <3> 内装 734K

# 0804


```python
1. 重量数据核对结果已经发给梁
2. t501工具还在整理中
```


```python
黑桃 - spades
红桃 - hearts
梅花 - clubs
方块 - diamonds
```


```python
REC联动：+193K
   <1>国内运费:REC連動，QCT経由REC+45,328(+1.8%)，運賃+8.6（+1.4%）
   <2>梱包資材費：REC連動▲4.9(▲3.1%)
```


```python
import datetime
from zoneinfo import ZoneInfo

# 获取当前日期和时间
current_datetime = datetime.datetime.now()

# 获取当前时区
current_timezone = ZoneInfo("Asia/Shanghai")

# 在当前时区下输出日期和时间
print(current_datetime.astimezone(current_timezone))
```


    ---------------------------------------------------------------------------

    ModuleNotFoundError                       Traceback (most recent call last)

    <ipython-input-5-76fac8ea34c5> in <module>
          1 import datetime
    ----> 2 from zoneinfo import ZoneInfo
          3 
          4 # 获取当前日期和时间
          5 current_datetime = datetime.datetime.now()
    

    ModuleNotFoundError: No module named 'zoneinfo'



```python
import datetime
import pytz

# 获取当前日期和时间
current_datetime = datetime.datetime.now()

# 获取当前时区
current_timezone = pytz.timezone("Asia/Shanghai")

# 在当前时区下输出日期和时间
print(current_datetime.astimezone(current_timezone))
```

    2023-08-10 09:45:17.640694+08:00
    


```python
#python3.9可用
import datetime
from zoneinfo import ZoneInfo

# 获取当前日期和时间
current_datetime = datetime.datetime.now()

# 获取当前时区
current_timezone = ZoneInfo("Asia/Shanghai")

# 在当前时区下输出日期和时间
print(current_datetime.astimezone(current_timezone))
```


```python
a='20230808'
```


```python
a[0:6]
```




    '202308'




```python
# coding: utf8
%load_ext autoreload
%autoreload 2 

import sys
sys.path.append("/work/src/lib")
#sys.path
from myslib import *
```

    The autoreload extension is already loaded. To reload it, use:
      %reload_ext autoreload
    


```python
dates = TimeUtil()
```


```python
dates.get_month_dates()
```




    {'first_day_of_last_month': '2023-07-01',
     'last_day_of_last_month': '2023-07-31',
     'first_day_of_this_month': '2023-08-01',
     'yesterday': '2023-08-09'}




```python
dates.get_time('M')
```




    '202308'




```python
dates.get_time('M-1')
```




    '202307'




```python

```


```python
# download.py demo
import os           # 导入操作系统模块，用于处理文件路径和目录
import re           # 导入正则表达式模块，用于匹配字符串
import requests     # 导入请求模块，用于网络请求

file_name = 'book_list.txt'  # 存储书籍列表的文件名
download_dir = './'          # 下载文件的存储目录

'''example
https://r2-ndr.ykt.cbern.com.cn/edu_product/esp/assets_document/bdc00134-465d-454b-a541-dcd0cec4d86e.pkg/pdf.pdf
  out=教材/电子教材/小学/道德与法治/统编版/一年级/上册/义务教育教科书·道德与法治一年级上册.pdf
'''
# 示例：包含下载链接和目标路径的书籍列表文件。每行格式为 "下载链接 out=目标路径"，本段代码定义了一个示例。

def get_links(file_name):
    with open(file_name, 'r', encoding='utf-8') as f:
        data = f.read()

    pattern = re.compile(r'(https\S+)\n\s+out=([^\n]+)')
    matches = pattern.findall(data)

    for match in matches:
        yield match
# 从书籍列表文件中提取下载链接和目标路径的生成器函数。该函数逐行读取文件内容，使用正则表达式匹配每行中的下载链接和目标路径。
# 通过 yield 将每一对匹配结果返回为一个生成器对象。

def download(link, path, session=requests.Session()):
    download_dir_name = os.path.join(download_dir, path)
    if not os.path.exists((os.path.dirname(download_dir_name))):
        os.makedirs(os.path.dirname(download_dir_name))
    # 根据给定的下载路径构建本地存储目录，如果目录不存在则创建

    with session.get(link, stream=True) as r:
        with open(download_dir_name, 'wb') as f:
            r.raw.decode_content = True
            downloaded_size = 0
            for chunk in r.iter_content(chunk_size=1024 * 1024 * 1024):
                f.write(chunk)
                downloaded_size += len(chunk)
                print(download_dir_name.split('/')[-1], downloaded_size, '/', r.headers['Content-Length'], end='\r')
# 使用 requests 库发送 GET 请求并下载文件。通过 stream=True 参数开启流式下载，使用迭代器逐块写入文件。

if __name__ == '__main__':
    import threading

    sub_threads = threading.Semaphore(8)
    # 创建信号量，用于控制同时进行的下载线程数量

    def download_thread(link, path):
        sub_threads.acquire()
        print('Download: ', path, link, end='\n')
        download(link, path)
        sub_threads.release()
        print('Done: ', path, end='\n')
    # 下载线程函数，使用信号量控制最大并发数。在开始下载前获取信号量，结束后释放信号量。

    for link, path in get_links(file_name):
        t = threading.Thread(target=download_thread, args=(link, path))
        t.start()
    # 遍历书籍列表中的下载链接和目标路径，为每一个下载任务创建一个线程并启动。
```


```python
import pytz
from datetime import datetime, timedelta
```


```python
datetime.today()
```




    datetime.datetime(2023, 8, 11, 3, 16, 42, 836810)




```python
datetime.now(tz=pytz.timezone('Asia/Shanghai'))
```




    datetime.datetime(2023, 8, 11, 11, 17, 30, 229549, tzinfo=<DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD>)



# 0821 


```python
老尤要比较印度尼西亚、中国 投诉、生产性
GKPI下载到7月
IDN就是印尼的缩写
```


```python
# 黑盒圣经
# https://github.com/heygsc/xiaoheihe-literature

```


```python
#切分txt里的字符串
```


```python
data = []

with open('your_file.txt', 'r') as file:
    for line in file:
        fields = line.strip().split('\t')  # 制表符
        fields = line.strip().split('  ')  # 注意这里是两个空格
        word = fields[0]
        meaning = fields[1]
        sentence = fields[2]
        
        entry = {
            'word': word,
            'meaning': meaning,
            'sentence': sentence
        }
        
        data.append(entry)
```


```python
即今空有梦为蝶，当日会将命乞花。
```


```python
平仄对联：
宇宙浩瀚如海洋，人我微尘沧海间

对仗对联：
宇宙广袤苍穹远，渺我尘埃自凡间
```

# 0824


```python
给人项目推进比较慢的感觉，原因是什么？（为啥会给人这样的感觉。）

流程
项目整体的deadline设定好了吗？
分阶段的交期设定好了吗？
原项目的周期设小了？

框架
项目人力配置问题？
几个项目间存在资源分配的瓶颈？
section间业务的连携？



目标： 整理
不论是内容、流程、做法


优先度的设定 (背后的作用意义)

#切入口
1. 广州AGV 分析
2. 小型荷合机
3. 新仓库 AGV
```

# 0829


```python
# 快速生成 EDA分析报告
```


```python
import sweetviz as sv

sweet_report= sv.analyze(df)
sweet_report.show_html('analzye.html')

sweet_report.show_notebook(layout='widescreen')
```

# 0830


```python
BMM主动举手发言：
1. 陈凤 *2
2. 许军 *1
3. 于娥 *1
```
