## 20240603


```python
周进度PJ
```


```python
1. TBMS
2. 目管表
3. KPI修正
4. TMM会议纪要
```


```python

```


```python
我要做一个即时设备监控功能。
分成两个功能，
1. 报表显示。
    显示什么设备在什么时候发生了故障。什么时候解决了故障。
    为了优先当前未排出的故障信息。是不是要分成两张表。没解决的故障一张表。解决后。数据推送到历史表。这样设计是不是合理。
2. 报警功能
    当设备故障时，就把设备故障发送一条信息。
    当设备故障解除时，也会发送一个信息。通知故障解除。
    当设备状态稳定，没有变化时。不推送。
    这样需求的功能，对应的表要如何设计才合理。能和即时数据和历史数据的需求结合起来设计吗？
```


```python
import base64
from IPython.display import Image, display

def visualize_flowchart():
    graph = """
        graph LR;
        A(开始) --> B(监测设备状态)
        B --> C{设备状态变化？}
        C -- 是 --> D(记录设备状态)
        D --> E{设备状态为故障？}
        E -- 是 --> F(记录故障信息)
        F --> G(发送故障报警信息)
        G --> H(结束)
        E -- 否 --> H(结束)
        C -- 否 --> H(结束)
    """
    graphbytes = graph.encode("utf-8")
    base64_bytes = base64.b64encode(graphbytes)
    base64_string = base64_bytes.decode("utf-8")
    display(Image(url="https://mermaid.ink/img/" + base64_string))
    
visualize_flowchart()
```


<img src="https://mermaid.ink/img/CiAgICAgICAgZ3JhcGggTFI7CiAgICAgICAgQSjlvIDlp4spIC0tPiBCKOebkea1i+iuvuWkh+eKtuaAgSkKICAgICAgICBCIC0tPiBDe+iuvuWkh+eKtuaAgeWPmOWMlu+8n30KICAgICAgICBDIC0tIOaYryAtLT4gRCjorrDlvZXorr7lpIfnirbmgIEpCiAgICAgICAgRCAtLT4gRXvorr7lpIfnirbmgIHkuLrmlYXpmpzvvJ99CiAgICAgICAgRSAtLSDmmK8gLS0+IEYo6K6w5b2V5pWF6Zqc5L+h5oGvKQogICAgICAgIEYgLS0+IEco5Y+R6YCB5pWF6Zqc5oql6K2m5L+h5oGvKQogICAgICAgIEcgLS0+IEgo57uT5p2fKQogICAgICAgIEUgLS0g5ZCmIC0tPiBIKOe7k+adnykKICAgICAgICBDIC0tIOWQpiAtLT4gSCjnu5PmnZ8pCiAgICA="/>



```python
很抱歉，我无法直接画出一个流程图来，但是我可以描述一下流程图的内容和布局，然后你可以根据这些信息手动制作或者使用流程图软件来制作。

流程图可能包含以下步骤：

1. 设备状态检测
   - [开始] → [设备状态检测]

2. 判断设备是否故障
   - [设备状态检测] → [设备是否故障？] 
        - 是 → [记录故障信息到 `current_faults` 表]
        - 否 → [设备运行正常]

3. 报警推送（如果新故障被检测到）
   - [记录故障信息到 `current_faults` 表] → [发出故障报警]

4. 实时报表更新（包括新检测到的故障）
   - [发出故障报警] → [实时报表显示当前故障]

5. 故障解决
   - [检测到故障解决] → [故障信息更新为 "解决"]
   - [实时报表移除解决的故障]

6. 故障归档到历史记录
   - [故障信息更新为 "解决"] → [移动到 `historical_faults` 表]

7. 报警解除推送
   - [移动到 `historical_faults` 表] → [发出故障解除通知]

这个流程图是一个简化的示意。你可以根据实际情况添加或修改某些步骤，比如增加异常处理、权限验证、用户通知偏好设置等。记得流程图的绘制应该清晰、简洁且具有指导性，以便于团队成员了解和执行相关流程。
```


```python
[Start]
   |
   V
[Device Status Check]
   |
   +--> [Is there a malfunction?]
             | Yes
             V
       [Record Fault in `current_faults`]
             |
             +--> [Send Fault Alarm]
                     |
                     V
              [Update Real-Time Report]
                     |
                     +--------------------+
                     |                    |
[Is malfunction resolved?]              [No]
   | Yes                                  |
   V                                      |
[Update Fault as "Resolved"] <------------+
   |
   +--> [Move to `historical_faults`]
             |
             +--> [Send Fault Resolved Notification]
                     |
                     V
                 [End]
```


```python
[开始]
   |
   V
[检测设备状态]
   |
   +--> [设备有故障吗？]
             | 有
             V
       [记录故障至 `current_faults` 表]
             |
             +--> [发送故障报警]
                     |
                     V
              [更新实时报表显示故障]
                     |
                     +--------------------+
                     |                    |
          [故障已解决？]               [没有]
             | 是                           |
             V                             |
[更新故障状态为 “已解决”] <------------+
   |
   +--> [移动至 `historical_faults` 表]
             |
             +--> [发送故障解除通知]
                     |
                     V
                 [结束]
```


```python
import base64
from IPython.display import Image, display

def visualize_flowchart():
    graph = """
        graph LR
            A[开始] --> B[检测设备状态]
            B --> C{设备有故障吗？}
            C -->|是| D[记录故障至 'current_faults' 表]
            C -->|否| E[设备运行正常]
            D --> F[发送故障报警]
            F --> G[更新实时报表显示故障]
            G --> H{故障已解决？}
            H -->|是| I[更新故障状态为 '已解决']
            H -->|否| G
            I --> J[移动至 'historical_faults' 表]
            J --> K[发送故障解除通知]
            K --> L[结束]
    """
    graphbytes = graph.encode("utf-8")
    base64_bytes = base64.b64encode(graphbytes)
    base64_string = base64_bytes.decode("utf-8")
    display(Image(url="https://mermaid.ink/img/" + base64_string))
    
visualize_flowchart()
```


<img src="https://mermaid.ink/img/CiAgICAgICAgZ3JhcGggTFIKICAgICAgICAgICAgQVvlvIDlp4tdIC0tPiBCW+ajgOa1i+iuvuWkh+eKtuaAgV0KICAgICAgICAgICAgQiAtLT4gQ3vorr7lpIfmnInmlYXpmpzlkJfvvJ99CiAgICAgICAgICAgIEMgLS0+fOaYr3wgRFvorrDlvZXmlYXpmpzoh7MgJ2N1cnJlbnRfZmF1bHRzJyDooahdCiAgICAgICAgICAgIEMgLS0+fOWQpnwgRVvorr7lpIfov5DooYzmraPluLhdCiAgICAgICAgICAgIEQgLS0+IEZb5Y+R6YCB5pWF6Zqc5oql6K2mXQogICAgICAgICAgICBGIC0tPiBHW+abtOaWsOWunuaXtuaKpeihqOaYvuekuuaVhemanF0KICAgICAgICAgICAgRyAtLT4gSHvmlYXpmpzlt7Lop6PlhrPvvJ99CiAgICAgICAgICAgIEggLS0+fOaYr3wgSVvmm7TmlrDmlYXpmpznirbmgIHkuLogJ+W3suino+WGsyddCiAgICAgICAgICAgIEggLS0+fOWQpnwgRwogICAgICAgICAgICBJIC0tPiBKW+enu+WKqOiHsyAnaGlzdG9yaWNhbF9mYXVsdHMnIOihqF0KICAgICAgICAgICAgSiAtLT4gS1vlj5HpgIHmlYXpmpzop6PpmaTpgJrnn6VdCiAgICAgICAgICAgIEsgLS0+IExb57uT5p2fXQogICAg"/>



```python
def visualize_flowchart(graph):
    graphbytes = graph.encode("utf-8")
    base64_bytes = base64.b64encode(graphbytes)
    base64_string = base64_bytes.decode("utf-8")
    display(Image(url="https://mermaid.ink/img/" + base64_string))
```


```python
graph = """
%%{init: {'theme':'base', 'themeVariables': { 'primaryColor': '#ffcccc', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': '#f0f0f0'}}}%%
graph TD
    subgraph 程序
    A[开始] --> B[检测设备状态]
    B --> C{设备有故障吗？}
    C -->|是| D[记录故障至 'current_faults' 表]
    C -->|否| E[设备运行正常]
    D --> F[发送故障报警]
    F --> G[更新实时报表显示故障]
    G --> H{故障已解决？}
    H -->|是| I[更新故障状态为 '已解决']
    H -->|否| G
    I --> J[移动至 'historical_faults' 表]
    J --> K[发送故障解除通知]
    K --> L[结束]
    end
    
    subgraph DB
    D --> M[DB: 记录进 'current_faults']
    I --> N[DB: 状态更新为 '已解决']
    J --> O[DB: 移至 'historical_faults']
    end
"""
```


```python
graph = """
%%{init: {'theme':'default', 'themeVariables': { 'primaryColor': '#ffcccc', 'edgeLabelBackground':'#ffffff', 'tertiaryColor': '#f0f0f0'}}}%%
graph TD
    %% 设备
    subgraph 设备
    A[开始] --> B[检测设备状态]
    B -->|发现故障| D[发送故障信息]
    B -->|运行正常| E[设备正常工作]
    end
    
    %% 数据库
    subgraph DB
    D --> F[记录故障至 'current_faults' 表]
    H --> I[更新故障状态为 '已解决']
    I --> J[移动至 'historical_faults' 表]
    end
    
    %% 用户
    subgraph 用户
    D --> G[接收故障报警]
    G --> H{故障已解决？}
    H -->|是| K[通知数据库更新状态]
    H -->|否| G
    K --> L[发送故障解除通知]
    end

"""
```


```python
visualize_flowchart(graph)
```


<img src="https://mermaid.ink/img/CiUle2luaXQ6IHsndGhlbWUnOidkZWZhdWx0JywgJ3RoZW1lVmFyaWFibGVzJzogeyAncHJpbWFyeUNvbG9yJzogJyNmZmNjY2MnLCAnZWRnZUxhYmVsQmFja2dyb3VuZCc6JyNmZmZmZmYnLCAndGVydGlhcnlDb2xvcic6ICcjZjBmMGYwJ319fSUlCmdyYXBoIFRECiAgICAlJSDorr7lpIcKICAgIHN1YmdyYXBoIOiuvuWkhwogICAgQVvlvIDlp4tdIC0tPiBCW+ajgOa1i+iuvuWkh+eKtuaAgV0KICAgIEIgLS0+fOWPkeeOsOaVhemanHwgRFvlj5HpgIHmlYXpmpzkv6Hmga9dCiAgICBCIC0tPnzov5DooYzmraPluLh8IEVb6K6+5aSH5q2j5bi45bel5L2cXQogICAgZW5kCiAgICAKICAgICUlIOaVsOaNruW6kwogICAgc3ViZ3JhcGggREIKICAgIEQgLS0+IEZb6K6w5b2V5pWF6Zqc6IezICdjdXJyZW50X2ZhdWx0cycg6KGoXQogICAgSCAtLT4gSVvmm7TmlrDmlYXpmpznirbmgIHkuLogJ+W3suino+WGsyddCiAgICBJIC0tPiBKW+enu+WKqOiHsyAnaGlzdG9yaWNhbF9mYXVsdHMnIOihqF0KICAgIGVuZAogICAgCiAgICAlJSDnlKjmiLcKICAgIHN1YmdyYXBoIOeUqOaItwogICAgRCAtLT4gR1vmjqXmlLbmlYXpmpzmiqXoraZdCiAgICBHIC0tPiBIe+aVhemanOW3suino+WGs++8n30KICAgIEggLS0+fOaYr3wgS1vpgJrnn6XmlbDmja7lupPmm7TmlrDnirbmgIFdCiAgICBIIC0tPnzlkKZ8IEcKICAgIEsgLS0+IExb5Y+R6YCB5pWF6Zqc6Kej6Zmk6YCa55+lXQogICAgZW5kCgo="/>


## 20240606


```python
 日本定例会的资料准备 （周四 6/13）
1. 明确资料范围和内容 跟老周确认
    1. FY24_MPT業務一覧-本社へ報告
    2. FY24業務工数(24年4月計画・実績)
    
2. 明确提交时间
    1. PJ资源表 周一例会看内容。进行更新
    2. 周二看所有资料
    
```


```python
关于6月本社月次报告相关资料
资料提交时间：6/10(周一)
（6/11周二 跟张部长汇报确认）
地址： \\192.168.63.80\share\QCT Share\模式开发课\各种分享资料（找不到点这里）\日本向项目报告\FY24\6月
```


```python
1. 新仓库设备 点检保养的部件和内容洗出
先

2. 点检保养的流程和功能
这部分还是通过系统来实现。

```


```python
中考是一个重要的锻炼过程，是设立目标，为之努力的阶段性成长经历。这过程会帮助你走向成熟，认识到社会的多样性和复杂性，也会对自身产生更多的认识。会引导你不断前行，从一个阶段步入另一个阶段。
然而，中考并不会成为你人生的全部。人生的旅途漫长且风景怡然，每个阶段都有其独特的美丽和意义。为了心中的憧憬而努力，本身就是一件极具魅力的事情。
从不同年龄段的视角来看，15岁的孩子可能会觉得中考是他们的全部，而对于50岁的人来说，中考只是人生长河中的一个小波澜。每个年龄段都会有不同的重点和挑战，我们在不同的阶段中不断寻求和实现自己的价值，这才是人生的真正意义所在。

```

## 0607


```python
TMM 0624 10~12点


设备故障率：看下故障次数与故障时长的关系
孙雨分析

C:\E\工作分类\FY24\10_TMM_KPI\202406 
    
5月份TMM KPI_顾（故障时长）_0611.xlsm


故障率数字确认和逻辑修正
已确认并修正




C. 与维保团队明确保养流程，并协助他们制作线下模型，自动计算保养项与时间计划讨论了设备点检、保养周期需求
1. 设备保养部件及内容整理（需要维保人员先整理出样板）
2. 周计划提醒及管理功能（建议第二期实施）

缺少流程图
```

## 20240619


```python
1. NG时增加：语音（TTS、或者播放音源)、 NG颜色显示（红色？？）
2. 秤外接接口，控制开关
3. DPC、DCC不同的移动动线
```

## 20240621


```python
在线16进制编辑器 https://hexed.it/
起始位 75 31 
1. 16进制→ 二进制。
    "75" = "0111 0101"， "31"= "0011 0001"。
    "75 31" = "0111 0101 0011 0001"。
2. 二进制 → 十进制。
    "0111 0101 0011 0001"="30001"
```


```python
import numpy as np
import pandas as pd

# 生成一个随机数列
np.random.seed(0)  # 设置随机种子以保证结果的可重复性
#series = pd.Series(np.random.randint(1, 100, 100))  # 生成一个包含100个1到100之间的随机整数的数列
#series = pd.Series(range(1, 401))
series = pd.Series([i for i in range(1, 101) for _ in range(4)])

# 计算四分位数
Q1 = series.quantile(0.25)
Q2 = series.quantile(0.5)
Q3 = series.quantile(0.75)
Q4 = series.quantile(1)

print("First Quartile (Q1): ", Q1)
print("Second Quartile (Q2/Median): ", Q2)
print("Third Quartile (Q3): ", Q3)
print("Fourth Quartile (Q4/Max): ", Q4)
```

    First Quartile (Q1):  25.75
    Second Quartile (Q2/Median):  50.5
    Third Quartile (Q3):  75.25
    Fourth Quartile (Q4/Max):  100.0
    


```python
series.describe()
```


```python
pd.Series(range(1, 100))
```




    0      1
    1      2
    2      3
    3      4
    4      5
          ..
    94    95
    95    96
    96    97
    97    98
    98    99
    Length: 99, dtype: int64




```python
# 导入numpy库
import numpy as np
import pandas as pd

# 定义数据集
#data = [20, 25, 30, 35, 40, 45, 50, 55, 60]
#data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
data = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 计算数据个数
n = len(data)

# 判断数据个数的奇偶性
if n % 2 == 0:
    # 对于偶数个数据，计算第二个四分位数（上四分位数）
    q2 = np.median(data)
    # 将数据分为两部分，分别计算第一个四分位数和第三个四分位数
    lower_half = data[:n // 2]
    upper_half = data[n // 2:]
    q1 = np.median(lower_half)
    q3 = np.median(upper_half)
else:
    # 对于奇数个数据，计算中位数作为第二个四分位数
    q2 = np.median(data)
    # 将数据分为两部分，分别计算第一个四分位数和第三个四分位数
    lower_half = data[:n // 2]
    upper_half = data[n // 2 + 1:]
    q1 = np.median(lower_half)
    q3 = np.median(upper_half)

# 打印结果
print("第一四分位数（下四分位数）：", q1)
print("第二四分位数（中位数）：", q2)
print("第三四分位数（上四分位数）：", q3)
```

    第一四分位数（下四分位数）： 2.5
    第二四分位数（中位数）： 5.0
    第三四分位数（上四分位数）： 7.5
    


```python
# 创建数据框
df = pd.DataFrame(data, columns=['数据'])

# 使用describe()函数查看描述性统计信息
description = df['数据'].describe()

# 打印结果
print(description)
```

    count    99.000000
    mean     50.000000
    std      28.722813
    min       1.000000
    25%      25.500000
    50%      50.000000
    75%      74.500000
    max      99.000000
    Name: 数据, dtype: float64
    


```python
# 生成包含1到100的列表
data = list(range(1, 100))

# 获取第25、50和75个元素
q1 = data[24]
q2 = data[49]
q3 = data[74]

# 打印结果
print("第一四分位数：", q1)
print("第二四分位数：", q2)
print("第三四分位数：", q3)
```

    第一四分位数： 25
    第二四分位数： 50
    第三四分位数： 75
    第一四分位数： 25
    第二四分位数： 50
    第三四分位数： 75
    


```python
    Dim sql1 As String
    DoCmd.SetWarnings False
    sql1 = "DELETE [6EntrySheets_SERV].* FROM 6EntrySheets_SERV;"
    DoCmd.RunSQL (sql1)
    DoCmd.SetWarnings True
    Me.Lbl_SysInfo.Caption = "盘点信息已清除!"
```


```python
DoCmd.TransferSpreadsheet acImport, 8, "6EntrySheets_SERV", xz, True
```


```python
Private Sub Command1_Click()    '49,50数据导入
    On Error GoTo err1
    Dim result As Integer, i As Integer
    Dim sql1 As String, wjq As String
    DoCmd.SetWarnings False
    Dim xz As String, wjm As String, v As String
    With Application.FileDialog(msoFileDialogFilePicker)
        .Filters.Clear
        .Title = "请选择所需的文本文件"
        .Filters.Add "文本文件", "*.TXT"
        .AllowMultiSelect = True
        .InitialFileName = CurrentProject.Path
        result = .Show
        
        If result <> 0 Then
            For i = 1 To .SelectedItems.Count
                xz = .SelectedItems.Item(i)
                wjq = Mid(xz, InStrRev(xz, "\") + 1)
                wjm = Left(wjq, Len(wjq) - 4)
                '  MsgBox "第" & i & "个 文件名：" & wjm
                On Error Resume Next
                DoCmd.TransferText acImportDelim, "MAGI_D_DATA_Import_New", "MAGI_SHP_DATA", xz
                DoCmd.TransferText acImportDelim, "MAGI_H_DATA_Import_New", "MAGI_H_DATA", xz
                DoCmd.DeleteObject acTable, wjm & "_导入错误"
                DoCmd.DeleteObject acTable, wjm & "_导入错误1"
                DoCmd.DeleteObject acTable, wjm & "_输入错误"
                DoCmd.DeleteObject acTable, wjm & "_输入错误1"
                DoCmd.DeleteObject acTable, "名称自动更正保存失败"
            Next
        Else
            MsgBox "取消选择文件！"
            Exit Sub
        End If
    End With
    
    sql1 = "DELETE MAGI_H_DATA.*, MAGI_H_DATA.[Control Flag] FROM MAGI_H_DATA WHERE (((MAGI_H_DATA.[Control Flag])='D'));"
    DoCmd.RunSQL (sql1)
    sql1 = "DELETE MAGI_SHP_DATA.Control_Flag, MAGI_SHP_DATA.* FROM MAGI_SHP_DATA WHERE (((MAGI_SHP_DATA.Control_Flag)='H'));"
    DoCmd.RunSQL (sql1)
    Me.Lbl_SysInfo.Caption = "②49,50数据导入完毕！"
    DoCmd.SetWarnings True
    Exit Sub
err1:
    Call ErrMsg
End Sub
```


```python
Private Sub Command33_Click()    'F2数据导入
    On Error GoTo err1
    Dim result, i As Integer
    DoCmd.SetWarnings False
    Dim xz, wjm, sql1, wjq, v As String
    
    sql1 = " DELETE MAGI_Search_Shipping_Data_Past.* FROM MAGI_Search_Shipping_Data_Past;"
    DoCmd.RunSQL (sql1)
    sql1 = " DELETE MAGI_Search_Shipping_Data.* FROM MAGI_Search_Shipping_Data;"
    DoCmd.RunSQL (sql1)
    
    With Application.FileDialog(msoFileDialogFilePicker)
        .Filters.Clear
        .Title = "请选择所需的文本文件"
        .Filters.Add "文本文件", "*.CSV"
        .AllowMultiSelect = True
        .InitialFileName = CurrentProject.Path
        result = .Show
        
        If result <> 0 Then
            For i = 1 To .SelectedItems.Count
                xz = .SelectedItems.Item(i)
                wjq = Mid(xz, InStrRev(xz, "\") + 1)
                wjm = Left(wjq, Len(wjq) - 4)
                '  MsgBox "第" & i & "个 文件名：" & wjm
                On Error Resume Next
                'DoCmd.TransferText acImportDelim, "F2_shipment_data_IMPORT", "MAGI_Search_Shipping_Data_Past", xz
                DoCmd.TransferText acImportDelim, "F2_Shipping_Data_Import_new", "MAGI_Search_Shipping_Data", xz
                DoCmd.DeleteObject acTable, wjm & "_导入错误"
                DoCmd.DeleteObject acTable, wjm & "_输入错误"
                '  DoCmd.DeleteObject acTable, "名称自动更正保存失败"
            Next
        Else
            MsgBox "取消选择文件！"
            Exit Sub
        End If
    End With
    '  Call FPAST2NEW
   ' Call PCI_Process
     Me.Lbl_SysInfo.Caption = "③F2数据导入完毕!"
    DoCmd.SetWarnings True
    Exit Sub
err1:
    Call ErrMsg
End Sub
```


```python
Private Sub Command54_Click()    'OrderPick 测试数据导入
    On Error GoTo err1
    Dim result As Integer, i As Integer
    Dim sql1 As String, wjq As String
    DoCmd.SetWarnings False
    Dim xz As String, wjm As String, v As String
    sql1 = "DELETE dOrderPickData.* FROM dOrderPickData;"
    DoCmd.RunSQL (sql1)
    
    With Application.FileDialog(msoFileDialogFilePicker)
        .Filters.Clear
        .Title = "请选择所需的表格文件"
        .Filters.Add "表格文件", "*.xlsx"
        .AllowMultiSelect = True
        .InitialFileName = CurrentProject.Path
        result = .Show
        
        If result <> 0 Then
            For i = 1 To .SelectedItems.Count
                xz = .SelectedItems.Item(i)
                wjq = Mid(xz, InStrRev(xz, "\") + 1)
                wjm = Left(wjq, Len(wjq) - 5)
                DoCmd.TransferSpreadsheet acImport, acSpreadsheetTypeExcel12Xml, "dOrderPickData", xz, 1
            Next
        Else
            MsgBox "取消选择文件！"
            Exit Sub
        End If
    End With
    Me.Lbl_SysInfo.Caption = "OrderPick导入完毕！"
    DoCmd.SetWarnings True
    Exit Sub
err1:
    Call ErrMsg
End Sub
```


```python
Sub exportxlsx()
    On Error GoTo err1
    Dim result As Integer, i As Integer
    Dim wjq As String
    DoCmd.SetWarnings False
    Dim xz As String, wjm As String, v As String
    Dim newFileName As String ' 添加新的变量
    
    With Application.FileDialog(msoFileDialogSaveAs)
        .Title = "请选择导出文件路径"
       ' .InitialFileName = CurrentProject.Path
        .InitialFileName = CurrentProject.Path & "\商品库位清单.xlsx"
        result = .Show
        
        If result = -1 Then
            xz = .SelectedItems.Item(1)
            ' 生成新的文件名
            If Right(xz, 5) = ".xlsx" Then
                newFileName = xz
            Else
                newFileName = xz & ".xlsx"
            End If
            
            ' 导出数据到新的文件
            DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "itm_lct_invt_qry", newFileName, True
        Else
            MsgBox "取消导出文件！"
            Exit Sub
        End If
    End With

    DoCmd.SetWarnings True
    Exit Sub
err1:
    MsgBox "错误号：" & Err.Number & Chr(10) + Chr(13) & "错误源：" & Err.Source & Chr(10) + Chr(13) & "错误描述：" & Err.Description, vbCritical
End Sub

```


```python
http://192.168.63.65:8800/QuartzUI
```


```python
# 20240625

1. 找AGV箱子 
2. AGV货箱地址备份逻辑补充

```


```python
Timesheet 
1. 木下跟韩国确认，改修内容。费用他们承担能否接受（有变化的话，需要重新报价）
2. 支付方式，要找蒋玲玲，问下JJ TSC 的支付流程。（如果通过JJ来收取的话，那是不是费用的支出直接由JJ去承担了?）
```

2. 需求分析
2.1 用户调研
访谈用户
收集需求
2.2 需求文档
编写需求规格说明书
确认需求文档
3. 系统设计
3.1 架构设计
确定系统架构
选择技术栈
3.2 详细设计
数据库设计
用户界面设计
功能模块设计
4. 开发
4.1 前端开发
界面开发
用户交互逻辑
4.2 后端开发
API 开发
数据库连接和操作
4.3 集成开发
前后端集成
第三方服务集成
5. 测试
5.1 单元测试
编写并执行单元测试
5.2 集成测试
测试各模块之间的集成
5.3 系统测试
系统整体测试
性能测试
安全测试
6. 部署
6.1 预生产环境部署
部署到预生产环境
执行最终测试
6.2 生产环境部署
部署到生产环境
系统上线
7. 运维与支持
7.1 监控与日志
设置系统监控
配置日志记录
7.2 用户培训
培训用户
编写用户手册
7.3 技术支持
提供技术支持
收集用户反馈并进行系统优化
关键里程碑
项目启动完成
需求分析完成并确认
系统设计完成并评审
开发完成并通过初步测试
系统部署完成并上线
项目验收并转入运维阶段


```python

```


```python
FROM centos:7

# 更新系统包
RUN yum -y update

# 安装httpd
RUN yum -y install httpd

# 安装依赖
RUN yum -y install libunwind libicu

# 安装Devtoolset以获取更新的libstdc++
RUN yum -y install centos-release-scl
RUN yum -y install devtoolset-9

# 激活Devtoolset
RUN scl enable devtoolset-9 bash

# 下载并安装 .NET 8 runtime
RUN curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh \
    && chmod +x dotnet-install.sh \
    && ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet \
    && ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# 清理安装脚本
RUN rm dotnet-install.sh

# 复制TBMS.dll文件到容器中
COPY C:/centos/publish /app

# 设置工作目录
WORKDIR /app

# 暴露端口
EXPOSE 80

# 设置启动命令
CMD scl enable devtoolset-9 bash -c "/usr/sbin/httpd -D FOREGROUND & dotnet /app/TBMS.dll"
```


```python
FROM centos:7

# 更新系统包
RUN yum -y update

# 安装httpd
RUN yum -y install httpd

# 安装依赖
RUN yum -y install libunwind libicu

# 复制本地的libstdc++库文件到镜像中
COPY /path/to/local/libstdc++.so.6 /usr/lib64/

# 下载并安装 .NET 8 runtime
RUN curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh \
    && chmod +x dotnet-install.sh \
    && ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet \
    && ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# 清理安装脚本
RUN rm dotnet-install.sh

# 复制TBMS.dll文件到容器中
COPY C:/centos/publish /app

# 设置工作目录
WORKDIR /app

# 暴露端口
EXPOSE 80

# 设置启动命令
CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"]
CMD ["dotnet", "/app/TBMS.dll"]
```


```python
FROM centos:7

# 更新系统包
RUN yum -y update

# 安装httpd
RUN yum -y install httpd

# 安装依赖
RUN yum -y install libunwind libicu

# 复制本地的libstdc++库文件到镜像中
COPY /path/to/local/libstdc++.so.6 /usr/lib64/

# 下载并安装 .NET 8 runtime
RUN curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh \
    && chmod +x dotnet-install.sh \
    && ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet \
    && ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# 清理安装脚本
RUN rm dotnet-install.sh

# 复制TBMS.dll文件到容器中
COPY C:/centos/publish /app

# 设置工作目录
WORKDIR /app

# 暴露端口
EXPOSE 80

# 设置启动命令
CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"]
CMD ["dotnet", "/app/TBMS.dll"]
```


```python

```

当然可以！你可以在容器内手动更新libstdc++组件。以下是如何通过命令行来更新这个组件的步骤。

### 1. 进入正在运行的容器

首先，确保你的容器正在运行。如果还没有运行，可以使用以下命令来启动它：

```sh
docker-compose up -d
```

然后，列出正在运行的容器，找到你的容器ID或名称：

```sh
docker ps
```

使用以下命令进入你的容器：

```sh
docker exec -it <container_id_or_name> /bin/bash
```

### 2. 手动更新libstdc++

现在你已经在容器内了，可以通过以下步骤手动更新libstdc++：

#### 安装Development Tools

首先，安装Development Tools，这将包括更新的libstdc++：

```sh
yum groupinstall -y "Development Tools"
```

#### 安装或更新devtoolset

你可以安装devtoolset来获取更新的libstdc++版本。以下是安装devtoolset-9的步骤：

```sh
yum install -y centos-release-scl
yum install -y devtoolset-9
scl enable devtoolset-9 bash
```

### 3. 验证更新

确保你已经成功安装了更新的libstdc++：

```sh
strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX
```

你应该能看到包含GLIBCXX_3.4.20和GLIBCXX_3.4.21的输出。

### 4. 重新启动你的.NET应用

现在你可以尝试重新启动你的.NET应用，确保它可以运行：

```sh
dotnet /app/TBMS.dll
```

### 5. 更新Dockerfile（可选）

如果手动更新解决了问题，可以将这些步骤添加到你的Dockerfile中，以便下次构建镜像时自动执行这些更新：

```dockerfile
FROM centos:7

# 更新系统包
RUN yum -y update

# 安装httpd
RUN yum -y install httpd

# 安装依赖
RUN yum -y install libunwind libicu

# 安装Development Tools
RUN yum groupinstall -y "Development Tools"

# 安装devtoolset-9
RUN yum -y install centos-release-scl
RUN yum -y install devtoolset-9
RUN scl enable devtoolset-9 bash

# 下载并安装 .NET 8 runtime
RUN curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh \
    && chmod +x dotnet-install.sh \
    && ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet \
    && ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# 清理安装脚本
RUN rm dotnet-install.sh

# 复制TBMS.dll文件到容器中
COPY C:/centos/publish /app

# 设置工作目录
WORKDIR /app

# 暴露端口
EXPOSE 80

# 设置启动命令
CMD scl enable devtoolset-9 bash -c "/usr/sbin/httpd -D FOREGROUND & dotnet /app/TBMS.dll"
```

通过这些步骤，你可以手动更新libstdc++组件，并确保.NET应用可以在容器中正常运行。希望这对你有帮助！

映射卷和复制文件是两种不同的方式，用于将主机上的文件和目录与容器内的文件和目录关联。两者有不同的使用场景和优点：

### 映射卷（Volumes）

使用映射卷的优点是主机上的文件和目录会直接映射到容器中，这意味着你可以在主机上更改文件，容器会自动看到这些更改。这对于开发和调试非常有用，因为你不需要每次更改文件后重建和重新启动容器。

在你的docker-compose.yml文件中，映射卷配置如下：

```yaml
volumes:
  - C:/centos/var/www/html:/var/www/html
  - C:/centos/publish:/app
```

### 复制文件（COPY 指令）

使用COPY指令的优点是文件会在镜像构建时被复制到镜像中，这意味着这些文件在镜像中是静态的，不会在容器运行时改变。这对于生产环境非常有用，因为它确保了容器内的文件不会被主机上的更改所影响，从而提供了更高的稳定性和一致性。

在你的Dockerfile中，COPY指令如下：

```dockerfile
COPY C:/centos/publish /app
```

### 为什么需要COPY指令

尽管你在docker-compose.yml文件中设置了卷映射，但在以下情况下，COPY指令仍然有其必要性：

1. **构建时依赖**：如果你的构建过程中需要使用这些文件，必须使用COPY指令，因为卷映射只有在容器运行时才生效。
2. **生产环境**：在生产环境中，你可能希望构建一个完整的、自包含的镜像，不依赖外部的文件。这种情况下，使用COPY指令可以确保镜像中的文件是确定的，不会因为主机上文件的变化而变化。

### 综合使用示例

为了在开发和生产环境中都能顺利使用，可以按照以下方式配置：

#### Dockerfile

只在Dockerfile中保留必要的步骤，不包含COPY指令：

```dockerfile
FROM centos:7

# 更新系统包并安装必要的工具
RUN yum -y update && \
    yum -y install centos-release-scl && \
    yum -y groupinstall "Development Tools" && \
    yum -y install devtoolset-9 && \
    yum -y install httpd libunwind libicu && \
    yum clean all

# 启用devtoolset-9以获取更新的libstdc++版本
RUN scl enable devtoolset-9 bash

# 下载并安装 .NET 8 runtime
RUN curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh \
    && chmod +x dotnet-install.sh \
    && ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet \
    && ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# 清理安装脚本
RUN rm dotnet-install.sh

# 设置工作目录
WORKDIR /app

# 暴露端口
EXPOSE 80

# 设置启动命令
CMD ["/usr/sbin/httpd", "-D", "FOREGROUND"]
CMD ["dotnet", "TBMS.dll"]
```

#### docker-compose.yml

使用卷映射来进行开发：

```yaml
version: '3'
services:
  web:
    image: my-centos
    ports:
      - "8085:80"
    volumes:
      - C:/centos/var/www/html:/var/www/html
      - C:/centos/publish:/app
```

### 生产环境

在生产环境中，你可以构建一个包含应用程序文件的镜像，并不使用卷映射：

#### Dockerfile（生产环境）

```dockerfile
FROM centos:7

# 更新系统包并安装必要的工具
RUN yum -y update && \
    yum -y install centos-release-scl && \
    yum -y groupinstall "Development Tools" && \
    yum -y install devtoolset-9 && \
    yum -y install httpd libunwind libicu && \
    yum clean all

# 启用devtoolset-9以获取更新的libstdc++版本
RUN scl enable devtoolset-9 bash

# 下载并安装 .NET 8 runtime
RUN curl -sSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh \
    && chmod +x dotnet-install.sh \
    && ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet \
    && ln -s /usr/share/dotnet/dotnet /usr/bin/dotnet

# 清理安装脚本
RUN rm dotnet-install.sh

# 设置工作目录
WORKDIR /app

# 复制应用程序文件
COPY C:/centos/publish /app

# 暴露端口
EXPOSE 80

# 设置启动命令
CMD ["dotnet", "TBMS.dll"]
```

通过这种方式，你可以在开发和生产环境中都能顺利使用你的镜像和容器。希望这些方法对你有帮助！


```python
ps aux | grep dotnet
```


```python
dotnet /app/TBMS.dll
```

## 报警信息


```python
dotnet /app/TBMS.dll
dotnet: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by dotnet)
dotnet: /lib64/libstdc++.so.6: version `GLIBCXX_3.4.21' not found (required by dotnet)
```


```python
cd /lib64/
```


```python
 cd /
```


```python
ls -al
```


```python
# 
yum install wget

wget http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip
```


```python
yum install unzip
    
unzip libstdc.so_.6.0.26.zip

mv libstdc++.so.6 libstdc++.so.6.bak

ln -s libstdc++.so.6.0.26 libstdc++.so.6

ls -l /lib64/libstdc++.so.6

dotnet /app/TBMS.dll

cd /
    
cd /app/

dotnet /app/TBMS.dll

dotnet TBMS.dll --urls http://*:8085
        
dotnet TBMS.dll --urls http://*:80
        
dotnet TBMS.dll --urls http://*:5000
```


```python
sudo yum install lsof
```


```python
sudo lsof -i :80
```

Based on the output you provided, it seems that the `httpd` process (Apache web server) is using port 80. This is why you are unable to bind to the same port for your application.

To resolve this issue, you have a few options:

1. Stop the Apache web server temporarily:
   ```shell
   sudo systemctl stop httpd
   ```

2. Change the port number for your application to a different available port, such as 8080. Update the command to:
   ```shell
   dotnet TBMS.dll --urls http://*:8080
   ```

3. If you don't need to use Apache, you can disable it permanently:
   ```shell
   sudo systemctl disable httpd
   ```

Once you have taken one of these actions, you should be able to run your application without encountering the "address already in use" error.

If you have any further questions, feel free to ask!


```python
要么 关掉默认的apache启动，改成手动启动
```


```python

```
