#0605 
1.G-ABC分摊 国内配送分摊出现异常
查到原因是有GLB是负值？？
变更了分摊运费的逻辑？？
国内配送李说他会去解决的。
2.5月FC 空运费用增加取消
原因：要调高经费的时候，需要有充分理由。只是看现象而跳高，不允许。有可能以后不发生
再观察一个月进行判定。


#0606


```python
★★★★★★PDF 下载：https://annas-archive.org/
```


```python
### 整理了各种各样的资源 AI、VPN、tools等
https://github.com/fmhy/FMHYedit
    
### 各种各样有意思的文章、资源。blog在_posts下    
https://wqw547243068.github.io/
https://github.com/wqw547243068/wqw547243068.github.io
     1.数据分析各种图表库的优劣和用法
      (wqw547243068.github.io/_posts/2013-10-30-data-vis.md）
       
机器学习之回归分析 - Regession Methods in Machine Learning
https://wqw547243068.github.io/regression
19种回归分析你知道几种呢？
https://www.toutiao.com/article/7137507638694281764/?wid=1686027939591
7种回归分析方法，数据分析师必须掌握！
https://zhuanlan.zhihu.com/p/58352024
五种回归方法的比较
https://www.cnblogs.com/jin-liang/p/9551759.html
```


```python
★★★嘉里第七笔申请 ，补充合同！！
合同地址:
\\192.168.63.80\share\QCT Share\新仓库PJ\03_建筑咨询\合同管理及成果物\嘉里达通
打印了PDF的1~4, 23-26

金额验证：
4326699.52/22=196,668.16元/月
第七笔:196668.16*3=590,004.48元
第八笔:196,668.16元
    
★★★QS第6笔 申元
就剩下第七笔：15.3万元

```


```python
#生成互动式透视表
from pivottablejs import pivot_ui
```


```python
# 生成互动式图标 - 类似tableau
import pygwalker as pyg
https://diagnostic-expert-advisor.readthedocs.io/en/latest/usage/visualization.html
https://github.com/Kanaries/pygwalker
https://github.com/Kanaries/graphic-walker/tree/c21f68b7bbd85e5e923cfcb3af1ed5331f3636c9
```


```python

```


```python
# coding: utf8
%load_ext autoreload
%autoreload 2 

import sys
sys.path.append("./lib")

from DBFetcherAnalyzer import *

data_comparator = DataComparator(mysqlcnn = myh.mysqlconnect(),mssqlcnn = msh.mssqlconnect())
dates = data_comparator.time_util.get_month_dates()

'''
dates
0 : 'first_day_of_last_month'
1 : 'last_day_of_last_month'
2 : 'first_day_of_this_month'
3 : 'yesterday'
'''

datebegin = list(dates.values())[0] # 或者 dates["first_day_of_last_month"]
dateend = list(dates.values())[1]

datebegin = list(dates.values())[2]
dateend = list(dates.values())[3]

t601_bc = data_comparator.compare_T601_data(datebegin, dateend)
t601_bc

t501_bc = data_comparator.compare_T501_data(datebegin, dateend)
t501_bc

t401_bc = data_comparator.compare_T401_data(datebegin, dateend)
t401_bc

t703_bc = data_comparator.compare_T703_data(datebegin, dateend)
t703_bc

#保存数据
merged_df = pd.concat(data_comparator.cache.values(), axis=1)
merged_df.to_excel(f'./数据比对{datebegin}-{dateend}.xlsx', index=False)


我想给以上代码通过客户端界面操作控制。下拉框三个、两个按钮、一个结果输出框
下拉框：datebegin、dateend、datatable
按钮：进行比对、导出到excel
结果输出框：result
1.下拉框<datebegin>、<dateend> ，默认里面填充 data_comparator.time_util.get_month_dates()，且下拉框可编辑写入。
2.下拉框<datatable> 默认 t401\t501\t601\t703
3.按钮<进行比对>：根据datatable来选择执行函数，其中的参数，等于datebegin、dateend
    data_comparator.compare_T401_data(datebegin, dateend)
    data_comparator.compare_T501_data(datebegin, dateend)
    data_comparator.compare_T601_data(datebegin, dateend)
    data_comparator.compare_T703_data(datebegin, dateend)
4.结果输出框<result>:把比对结果输出到这里。
5.按钮<导出到excel>：执行
merged_df = pd.concat(data_comparator.cache.values(), axis=1)
merged_df.to_excel(f'./数据比对{datebegin}-{dateend}.xlsx', index=False)

```


      File "<ipython-input-2-d1645c224687>", line 46
        我想给以上代码通过客户端界面操作控制。下拉框三个、两个按钮、一个结果输出框
                                            ^
    SyntaxError: invalid character in identifier
    



```python

```


```python
# coding: utf8
%load_ext autoreload
%autoreload 2 

import sys
sys.path.append("./lib")

from DBFetcherAnalyzer import *

data_exporter = DataExporter(mysqlcnn = myh.mysqlconnect(),mssqlcnn = msh.mssqlconnect())
dates = data_exporter.time_util.get_month_dates()

datebegin = dates["first_day_of_last_month"]
dateend = dates["last_day_of_last_month"]

datebegin = dates["first_day_of_this_month"]
dateend = dates["yesterday"]

datebegin ='2023-06-12'

print(datebegin,dateend)

#MYSQL_T401 SD出货数据
'''
用途: 出货数据日次下载
to: 积累日次数据用于月次KPI报告制作
地址: ./T401/
'''
data_exporter.export_T401_to_csv(datebegin, dateend)

#MSSQL_T703 移库数据
'''
用途: 移库数据前30天
to: 事务

'''
data_exporter.export_T703_30days_to_csv()

#MYSQL_T703 移库数据
'''
用途: 移库数据月次
to: 事务
地址:./output/
\\192.168.63.80\share\业务支援共享数据\DataService\T703
'''
data_exporter.export_T703_to_csv(datebegin, dateend)

#MYSQL_T501 SO_DATA
'''
用途: 配送部门PKI数据月次
to: 配送李
地址: ./output/
\\192.168.63.80\share\业务支援共享数据\DataService\T501
'''
data_exporter.export_T501_to_csv(datebegin, dateend)

#MSSQL_M104 stockmaster
'''
用途: 在库盘点报告
to: 物企陈
地址: ./output/
\\192.168.63.80\share\业务支援共享数据\DataService\M104
'''
data_exporter.export_M104_to_csv()

#MSSQL_M901 calendar
'''
用途: GKPI工具，日历更新
注: 当下载数据为空时，表述数据三个月内无变化已被清空

'''
data_exporter.export_m901_to_csv()

帮我做成一个界面
这部分写在page2下。
self.page2 = tk.Frame(self.notebook)
self.notebook.add(self.page2, text='数据下载')

我想给以上代码通过客户端界面操作控制。下拉框三个、两个按钮、一个结果输出框
下拉框：datebegin、dateend、datatable
按钮：进行下载
结果输出框：result

3.按钮<进行下载>：根据datatable来选择执行函数，其中的参数，等于data_exporter下的函数

4.结果输出框<result>:把下载的进度、信息、结果输出到这里。
```


    ---------------------------------------------------------------------------

    ModuleNotFoundError                       Traceback (most recent call last)

    <ipython-input-5-f03cb2670b0d> in <module>
          6 sys.path.append("./lib")
          7 
    ----> 8 from DBFetcherAnalyzer import *
          9 
         10 data_exporter = DataExporter(mysqlcnn = myh.mysqlconnect(),mssqlcnn = msh.mssqlconnect())
    

    ModuleNotFoundError: No module named 'DBFetcherAnalyzer'



```python

```


```python
# coding: utf8
%load_ext autoreload
%autoreload 2 

import sys
sys.path.append("./lib")

from KpiReportHelper import *

t601rpt = KpiReportT601(mysqlcnn = myh.mysqlconnect(),mssqlcnn = msh.mssqlconnect())

print(t601rpt.time_util.get_time())
'''
dates
0 : 'first_day_of_last_month'
1 : 'last_day_of_last_month'
2 : 'first_day_of_this_month'
3 : 'yesterday'
'''
dates = t601rpt.time_util.get_month_dates()

datebegin = list(dates.values())[0] # 或者 dates["first_day_of_last_month"]
dateend = list(dates.values())[1]
#datebegin = '2023-03-01'
#dateend = '2023-03-31'

datebegin,dateend

# ------------------------------------------------------------T601(arrvial) KPI_calculate-10_輸入Rec数------------------------------------------------------------
# 更新日期：2023-04-28 
# 计算整月的输入到货REC数
# 提取条件 'COUNTRY_CD'!=105 
##  国内:105,台湾:106，香港: 108 
#用途： P-KPI 出荷REC数 28行、30行
##相关引用：生産性&棚卸（现场） 74行
t601_res = t601rpt.calculate_kpi(datebegin, dateend)
t601_res

t601_res.to_excel(f'./output/入库数据_{t601rpt.time_util.get_time()}.xlsx', index=False)

# ------------------------------------------------------------T401(SD) KPI_calculate------------------------------------------------------------

path='./T401/'

t401rpt = KpiReportT401(path=path)

df=t401rpt.import_csvfile()

df=t401rpt.process_data(df, datebegin)

t401_res=t401rpt.calculate_kpi(df)
t401_res

df.to_csv(f'./output/t401-{datebegin}_{dateend}.csv',sep='\t', index=False,encoding='utf8')

t401_res.to_excel(f'./output/PKPI数据{t401rpt.time_util.get_time()}.xlsx',index=False)

帮我做成一个界面
这部分写在page3下。
self.page3 = tk.Frame(self.notebook)
self.notebook.add(self.page3, text='KPI报告生成')

我想给以上代码通过客户端界面操作控制。下拉框三个、两个按钮、一个结果输出框
下拉框：datebegin、dateend、datatable(t601,t401)、path(默认=./T401/)
按钮：KPI计算、导出到表格
结果输出框：result

3.按钮<KPI计算>：根据datatable来选择执行函数calculate_kpi。
  按钮<导出到文件>：导出结果到csv、xlsx文件

4.结果输出框<result>:把下载的进度、信息、结果输出到这里。

```


```python
import tkinter as tk
from tkinter import ttk
from tkinter.filedialog import askdirectory
from KpiReportHelper import *

class KpiReportGUI:
    def __init__(self, master):
        self.master = master
        master.title("KPI Report Generator")
        
        # Create notebook for multiple pages
        self.notebook = ttk.Notebook(master)
        self.notebook.pack(fill='both', expand=True)
        
        # Create page 3
        self.page3 = tk.Frame(self.notebook)
        self.notebook.add(self.page3, text='KPI报告生成')
        
        # Initialize variables for dropdown menus
        self.datebegin = tk.StringVar(value='')
        self.dateend = tk.StringVar(value='')
        self.datatable = tk.StringVar(value='t601')
        self.path = tk.StringVar(value='./T401/')
        
        # Create dropdown menus
        datebegin_label = tk.Label(self.page3, text='开始日期：')
        datebegin_label.grid(row=0, column=0, padx=5, pady=5)
        datebegin_menu = ttk.Combobox(self.page3, textvariable=self.datebegin)
        datebegin_menu['values'] = ['', 'first_day_of_last_month', 'last_day_of_last_month', 'first_day_of_this_month', 'yesterday']
        datebegin_menu.grid(row=0, column=1, padx=5, pady=5)
        
        dateend_label = tk.Label(self.page3, text='结束日期：')
        dateend_label.grid(row=1, column=0, padx=5, pady=5)
        dateend_menu = ttk.Combobox(self.page3, textvariable=self.dateend)
        dateend_menu['values'] = ['', 'first_day_of_last_month', 'last_day_of_last_month', 'first_day_of_this_month', 'yesterday']
        dateend_menu.grid(row=1, column=1, padx=5, pady=5)
        
        datatable_label = tk.Label(self.page3, text='数据表：')
        datatable_label.grid(row=2, column=0, padx=5, pady=5)
        datatable_menu = ttk.Combobox(self.page3, textvariable=self.datatable)
        datatable_menu['values'] = ['t601', 't401']
        datatable_menu.grid(row=2, column=1, padx=5, pady=5)
        
        path_label = tk.Label(self.page3, text='文件路径：')
        path_label.grid(row=3, column=0, padx=5, pady=5)
        path_entry = tk.Entry(self.page3, textvariable=self.path)
        path_entry.grid(row=3, column=1, padx=5, pady=5)
        browse_button = tk.Button(self.page3, text='浏览', command=self.browse_path)
        browse_button.grid(row=3, column=2, padx=5, pady=5)
        
        # Create buttons
        kpi_button = tk.Button(self.page3, text='KPI计算', command=self.calculate_kpi)
        kpi_button.grid(row=4, column=0, padx=5, pady=5)
        export_button = tk.Button(self.page3, text='导出到表格', command=self.export_results)
        export_button.grid(row=4, column=1, padx=5, pady=5)
        
        # Create result output box
        result_label = tk.Label(self.page3, text='结果输出：')
        result_label.grid(row=5, column=0, padx=5, pady=5)
        self.result_box = tk.Text(self.page3, height=10, width=50)
        self.result_box.grid(row=6, column=0, columnspan=3, padx=5, pady=5)
        
        # Initialize KpiReportHelper
        self.t601rpt = KpiReportT601(mysqlcnn=myh.mysqlconnect(), mssqlcnn=msh.mssqlconnect())
        self.t401rpt = KpiReportT401(path='./T401/')
    
    def browse_path(self):
        path = askdirectory()
        if path:
            self.path.set(path)
    
    def calculate_kpi(self):
        datebegin = self.datebegin.get()
        dateend = self.dateend.get()
        datatable = self.datatable.get()
        path = self.path.get()
        result_string = ''
        if datatable == 't601':
            try:
                res = self.t601rpt.calculate_kpi(datebegin, dateend)
                self.result_box.insert('end', f'T601 KPI calculated successfully!\n')
                result_string += str(res)
            except Exception as e:
                self.result_box.insert('end', f'Failed to calculate T601 KPI: {e}\n')

        elif datatable == 't401':
            try:
                df = self.t401rpt.import_csvfile()
                df = self.t401rpt.process_data(df, datebegin)
                t401_res = self.t401rpt.calculate_kpi(df)
                self.result_box.insert('end', f'T401 KPI calculated successfully!\n')
                result_string += str(t401_res)
            except Exception as e:
                self.result_box.insert('end', f'Failed to calculate T401 KPI: {e}\n')

        else:
            self.result_box.insert('end', 'Invalid datatable.\n')
        
        self.result_box.insert('end', result_string + '\n')
                
    def export_results(self):
        datatable = self.datatable.get()
        path = self.path.get()
        now = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'{datatable}_{now}.xlsx'
        if datatable == 't601':
            try:
                res = self.t601rpt.calculate_kpi(self.datebegin.get(), self.dateend.get())
                res.to_excel(f'{path}/{filename}', index=False)
                self.result_box.insert('end', f'T601 KPI exported to {path}/{filename}.\n')
            except Exception as e:
                self.result_box.insert('end', f'Failed to export T601 KPI: {e}\n')
        elif datatable == 't401':
            try:
                df = self.t401rpt.import_csvfile()
                df = self.t401rpt.process_data(df, self.datebegin.get())
                t401_res = self.t401rpt.calculate_kpi(df)
                t401_res.to_excel(f'{path}/{filename}', index=False)
                self.result_box.insert('end', f'T401 KPI exported to {path}/{filename}.\n')
            except Exception as e:
                self.result_box.insert('end', f'Failed to export T401 KPI: {e}\n')
        else:
            self.result_box.insert('end', 'Invalid datatable.\n')
```


```python
import threading
import tkinter as tk
import tkinter.messagebox as messagebox
from tkinter import ttk
from tkinter.filedialog import askdirectory
from KpiReportHelper import *

class KpiReportGUI:
    def __init__(self, master):
        self.master = master
        master.title("KPI Report Generator")
        
        # Create notebook for multiple pages
        self.notebook = ttk.Notebook(master)
        self.notebook.pack(fill='both', expand=True)
        
        # Create page 3
        self.page3 = tk.Frame(self.notebook)
        self.notebook.add(self.page3, text='KPI报告生成')
        
        # Initialize variables for dropdown menus
        self.datebegin = tk.StringVar(value='')
        self.dateend = tk.StringVar(value='')
        self.datatable = tk.StringVar(value='t601')
        self.path = tk.StringVar(value='./T401/')
        
        # Create dropdown menus
        datebegin_label = tk.Label(self.page3, text='开始日期：')
        datebegin_label.grid(row=0, column=0, padx=5, pady=5)
        datebegin_menu = ttk.Combobox(self.page3, textvariable=self.datebegin)
        datebegin_menu['values'] = ['', 'first_day_of_last_month', 'last_day_of_last_month', 'first_day_of_this_month', 'yesterday']
        datebegin_menu.grid(row=0, column=1, padx=5, pady=5)
        
        dateend_label = tk.Label(self.page3, text='结束日期：')
        dateend_label.grid(row=1, column=0, padx=5, pady=5)
        dateend_menu = ttk.Combobox(self.page3, textvariable=self.dateend)
        dateend_menu['values'] = ['', 'first_day_of_last_month', 'last_day_of_last_month', 'first_day_of_this_month', 'yesterday']
        dateend_menu.grid(row=1, column=1, padx=5, pady=5)
        
        datatable_label = tk.Label(self.page3, text='数据表：')
        datatable_label.grid(row=2, column=0, padx=5, pady=5)
        datatable_menu = ttk.Combobox(self.page3, textvariable=self.datatable)
        datatable_menu['values'] = ['t601', 't401']
        datatable_menu.grid(row=2, column=1, padx=5, pady=5)
        
        path_label = tk.Label(self.page3, text='文件路径：')
        path_label.grid(row=3, column=0, padx=5, pady=5)
        path_entry = tk.Entry(self.page3, textvariable=self.path)
        path_entry.grid(row=3, column=1, padx=5, pady=5)
        browse_button = tk.Button(self.page3, text='浏览', command=self.browse_path)
        browse_button.grid(row=3, column=2, padx=5, pady=5)
        
        # Create buttons
        kpi_button = tk.Button(self.page3, text='KPI计算', command=self.start_work)
        kpi_button.grid(row=4, column=0, padx=5, pady=5)
        export_button = tk.Button(self.page3, text='导出到表格', command=self.start_work)
        export_button.grid(row=4, column=1, padx=5, pady=5)
        
        # Create result output box
        result_label = tk.Label(self.page3, text='结果输出：')
        result_label.grid(row=5, column=0, padx=5, pady=5)
        self.result_box = tk.Text(self.page3, height=10, width=50)
        self.result_box.grid(row=6, column=0, columnspan=3, padx=5, pady=5)
        
        # Initialize KpiReportHelper
        self.t601rpt = KpiReportT601(mysqlcnn=myh.mysqlconnect(), mssqlcnn=msh.mssqlconnect())
        self.t401rpt = KpiReportT401(path='./T401/')
    
    def browse_path(self):
        path = askdirectory()
        if path:
            self.path.set(path)
    
    def start_work(self):
        # Disable buttons to prevent multiple clicks
        self.master.config(cursor='wait')
        for widget in self.page3.winfo_children():
            widget.config(state='disabled')
        
        # Start a new thread to do the work
        t = threading.Thread(target=self.do_work)
        t.daemon = True
        t.start()
    
    def do_work(self):
        try:
            datebegin = self.datebegin.get()
            dateend = self.dateend.get()
            datatable = self.datatable.get()
            path = self.path.get()
            result_string = ''
            
            if datatable == 't601':
                res = self.t601rpt.calculate_kpi(datebegin, dateend)
                self.result_box.insert('end', f'T601 KPI calculated successfully!\n')
                result_string += str(res)
                
                now = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f'{datatable}_{now}.xlsx'
                res.to_excel(f'{path}/{filename}', index=False)
                self.result_box.insert('end', f'T601 KPI exported to {path}/{filename}.\n')
                
            elif datatable == 't401':
                df = self.t401rpt.import_csvfile()
                df = self.t401rpt.process_data(df, datebegin)
                t401_res = self.t401rpt.calculate_kpi(df)
                self.result_box.insert('end', f'T401 KPI calculated successfully!\n')
                result_string += str(t401_res)
                
                now = datetime.now().strftime('%Y%m%d_%H%M%S')
                filename = f'{datatable}_{now}.xlsx'
                t401_res.to_excel(f'{path}/{filename}', index=False)
                self.result_box.insert('end', f'T401 KPI exported to {path}/{filename}.\n')
                
            else:
                raise ValueError('Invalid datatable.')
            
            self.result_box.insert('end', result_string + '\n')
        
        except Exception as e:
            messagebox.showerror('Error', str(e))
        
        finally:
            # Enable buttons again
            self.master.config(cursor='')
            for widget in self.page3.winfo_children():
                widget.config(state='normal')
    
if __name__ == '__main__':
    root = tk.Tk()
    app = KpiReportGUI(root)
    root.mainloop()
```


```python
# Funtion of Third page
    def browse_path(self):
        path = askdirectory()
        if path:
            self.path.set(path)
    
    def calculate_kpi(self):
        datebegin = self.datebegin_var3.get()
        dateend = self.dateend_var3.get()
        datatable = self.datatable_var3.get()
        path = self.path.get()
        result_string = ''
        if datatable == 't601':
            try:
                res = self.t601rpt.calculate_kpi(datebegin, dateend)
                self.result_text3.insert('end', f'T601 KPI calculated successfully!\n')
                result_string += str(res)
            except Exception as e:
                self.result_text3.insert('end', f'Failed to calculate T601 KPI: {e}\n')

        elif datatable == 't401':
            try:
                df = self.t401rpt.import_csvfile()
                df = self.t401rpt.process_data(df, datebegin)
                t401_res = self.t401rpt.calculate_kpi(df)
                self.result_text3.insert('end', f'T401 KPI calculated successfully!\n')
                result_string += str(t401_res)
            except Exception as e:
                self.result_text3.insert('end', f'Failed to calculate T401 KPI: {e}\n')

        else:
            self.result_text3.insert('end', 'Invalid datatable.\n')
        
        self.result_text3.insert('end', result_string + '\n')
                
    def export_results(self):
        datatable = self.datatable_var3.get()
        path = self.path.get()
        now = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'{datatable}_{now}.xlsx'
        if datatable == 't601':
            try:
                res = self.t601rpt.calculate_kpi(self.datebegin_var3.get(), self.dateend_var3.get())
                res.to_excel(f'{path}/{filename}', index=False)
                self.result_text3.insert('end', f'T601 KPI exported to {path}/{filename}.\n')
            except Exception as e:
                self.result_text3.insert('end', f'Failed to export T601 KPI: {e}\n')
        elif datatable == 't401':
            try:
                df = self.t401rpt.import_csvfile()
                df = self.t401rpt.process_data(df, self.datebegin_var3.get())
                t401_res = self.t401rpt.calculate_kpi(df)
                t401_res.to_excel(f'{path}/{filename}', index=False)
                self.result_text3.insert('end', f'T401 KPI exported to {path}/{filename}.\n')
            except Exception as e:
                self.result_text3.insert('end', f'Failed to export T401 KPI: {e}\n')
        else:
            self.result_text3.insert('end', 'Invalid datatable.\n')
            
    修改代码：
    1. 增加缓存机能，如果已经执行过。就不重复执行。
      1. t601是根据begin end来判定
      2. t401是根据导入的文件夹里的清单来判定
    2. calculate_kpi中增加一个步骤：df 保存在缓存里。(下一步会导出这个df)
    3. export_results判断缓存中已经有了哪些数据集合。如果存在t601就导出t601
       如果存在t401除了导出一个excel外，还需要增加导出df，代码参考这个：df.to_csv(f'./output/t401-{datebegin}_{dateend}.csv',sep='\t', index=False,encoding='utf8')
```


      File "<ipython-input-1-9b997b06cfc9>", line 2
        def browse_path(self):
        ^
    IndentationError: unexpected indent
    



```python
class ThirdPage(tk.Frame):
    def __init__(self, parent, t601rpt, t401rpt, cache_manager):
        tk.Frame.__init__(self, parent)
        
        self.t601rpt = t601rpt
        self.t401rpt = t401rpt
        self.cache_manager = cache_manager
        
        self.path = tk.StringVar()
        self.datebegin_var3 = tk.StringVar(value=(datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d'))
        self.dateend_var3 = tk.StringVar(value=datetime.now().strftime('%Y-%m-%d'))
        self.datatable_var3 = tk.StringVar(value='t601')
        
        # Path entry and browse button
        tk.Label(self, text="Path: ").grid(row=0, column=0, sticky=tk.W)
        tk.Entry(self, textvariable=self.path).grid(row=0, column=1)
        tk.Button(self, text="Browse", command=self.browse_path).grid(row=0, column=2)
        
        # Date range entry
        tk.Label(self, text="Date Range: ").grid(row=1, column=0, sticky=tk.W)
        tk.Entry(self, textvariable=self.datebegin_var3).grid(row=1, column=1)
        tk.Label(self, text="to").grid(row=1, column=2)
        tk.Entry(self, textvariable=self.dateend_var3).grid(row=1, column=3)
        
        # Datatable selection
        tk.Label(self, text="Datatable: ").grid(row=2, column=0, sticky=tk.W)
        tk.OptionMenu(self, self.datatable_var3, 't601', 't401').grid(row=2, column=1)
        
        # Calculate KPI button
        tk.Button(self, text="Calculate KPI", command=self.calculate_kpi).grid(row=3, column=0)
        
        # Export results button
        tk.Button(self, text="Export Results", command=self.export_results).grid(row=3, column=1)
        
        # Result text box
        self.result_text3 = tk.Text(self, height=10, width=100)
        self.result_text3.grid(row=4, columnspan=4)
    
    def browse_path(self):
        path = askdirectory()
        if path:
            self.path.set(path)
    
    def calculate_kpi(self):
        datebegin = self.datebegin_var3.get()
        dateend = self.dateend_var3.get()
        datatable = self.datatable_var3.get()
        path = self.path.get()
        result_string = ''
        
        if datatable == 't601':
            if self.cache_manager.t601_cache_exists(datebegin, dateend):
                res = self.cache_manager.get_t601_cache(datebegin, dateend)
                self.result_text3.insert('end', f'T601 KPI retrieved from cache!\n')
            else:
                try:
                    res = self.t601rpt.calculate_kpi(datebegin, dateend)
                    self.cache_manager.set_t601_cache(datebegin, dateend, res)
                    self.result_text3.insert('end', f'T601 KPI calculated successfully!\n')
                except Exception as e:
                    self.result_text3.insert('end', f'Failed to calculate T601 KPI: {e}\n')
        elif datatable == 't401':
            if self.cache_manager.t401_cache_exists(path):
                df = self.cache_manager.get_t401_cache(path)
                self.result_text3.insert('end', f'T401 data retrieved from cache!\n')
            else:
                try:
                    df = self.t401rpt.import_csvfile(path)
                    df = self.t401rpt.process_data(df, datebegin)
                    self.cache_manager.set_t401_cache(path, df)
                    self.result_text3.insert('end', f'T401 data imported and processed successfully!\n')
                except Exception as e:
                    self.result_text3.insert('end', f'Failed to import T401 data: {e}\n')
                
            try:
                t401_res = self.t401rpt.calculate_kpi(df)
                result_string += str(t401_res)
                self.result_text3.insert('end', f'T401 KPI calculated successfully!\n')
            except Exception as e:
                self.result_text3.insert('end', f'Failed to calculate T401 KPI: {e}\n')

        else:
            self.result_text3.insert('end', 'Invalid datatable.\n')
        
        self.result_text3.insert('end', result_string + '\n')
                
    def export_results(self):
        datatable = self.datatable_var3.get()
        path = self.path.get()
        now = datetime.now().strftime('%Y%m%d
```


```python
# initialize cache for t601 and t401
t601_cache = {}
t401_cache = {}

def browse_path(self):
    path = askdirectory()
    if path:
        self.path.set(path)

def calculate_kpi(self):
    datebegin = self.datebegin_var3.get()
    dateend = self.dateend_var3.get()
    datatable = self.datatable_var3.get()
    path = self.path.get()
    result_string = ''
    if datatable == 't601':
        if (datebegin, dateend) in t601_cache:
            res = t601_cache[(datebegin, dateend)]
            self.result_text3.insert('end', f'T601 KPI retrieved from cache.\n')
            result_string += str(res)
        else:
            try:
                res = self.t601rpt.calculate_kpi(datebegin, dateend)
                self.result_text3.insert('end', f'T601 KPI calculated successfully!\n')
                result_string += str(res)
                t601_cache[(datebegin, dateend)] = res # save to cache
            except Exception as e:
                self.result_text3.insert('end', f'Failed to calculate T601 KPI: {e}\n')

    elif datatable == 't401':
        if path in t401_cache:
            df = t401_cache[path]
            self.result_text3.insert('end', f'T401 data retrieved from cache.\n')
        else:
            try:
                df = self.t401rpt.import_csvfile(path)
                df = self.t401rpt.process_data(df, datebegin)
                self.result_text3.insert('end', f'T401 data processed successfully!\n')
                t401_cache[path] = df # save to cache
            except Exception as e:
                self.result_text3.insert('end', f'Failed to process T401 data: {e}\n')

        try:
            t401_res = self.t401rpt.calculate_kpi(df)
            self.result_text3.insert('end', f'T401 KPI calculated successfully!\n')
            result_string += str(t401_res)
        except Exception as e:
            self.result_text3.insert('end', f'Failed to calculate T401 KPI: {e}\n')

    else:
        self.result_text3.insert('end', 'Invalid datatable.\n')

    self.result_text3.insert('end', result_string + '\n')

def export_results(self):
    datatable = self.datatable_var3.get()
    path = self.path.get()
    now = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f'{datatable}_{now}.xlsx'
    if datatable == 't601':
        if (self.datebegin_var3.get(), self.dateend_var3.get()) in t601_cache:
            res = t601_cache[(self.datebegin_var3.get(), self.dateend_var3.get())]
        else:
            try:
                res = self.t601rpt.calculate_kpi(self.datebegin_var3.get(), self.dateend_var3.get())
                t601_cache[(self.datebegin_var3.get(), self.dateend_var3.get())] = res # save to cache
            except Exception as e:
                self.result_text3.insert('end', f'Failed to calculate T601 KPI: {e}\n')
                return

        try:
            res.to_excel(f'{path}/{filename}', index=False)
            self.result_text3.insert('end', f'T601 KPI exported to {path}/{filename}.\n')
        except Exception as e:
            self.result_text3.insert('end', f'Failed to export T601 KPI: {e}\n')

    elif datatable == 't401':
        if path in t401_cache:
            df = t401_cache[path]
        else:          
            try:
                df = self.t401rpt.import_csvfile(path)
                df = self.t401rpt.process_data(df, self.datebegin_var3.get())
                t401_cache[path] = df # save to cache
            except Exception as e:
                self.result_text3.insert('end', f'Failed to process T401 data: {e}\n')
                return

            try:
                t401_res = self.t401rpt.calculate_kpi(df)
                t401_res.to_excel(f'{path}/{filename}', index=False)
                self.result_text3.insert('end', f'T401 KPI exported to {path}/{filename}.\n')
                df.to_csv(f'./output/t401-{self.datebegin_var3.get()}_{self.dateend_var3.get()}.csv', sep='\t', index=False, encoding='utf8') # export df to csv
            except Exception as e:
                self.result_text3.insert('end', f'Failed to export T401 KPI: {e}\n')

    else:
        self.result_text3.insert('end', 'Invalid datatable.\n')
```

我想做一个工具，使用python tk。
功能如下：
1. 一个按钮能启动/关闭。启动时，抓取鼠标坐标的定位。显示在Xlabel,ylabel上。
2. 一个按钮获得当前的应用程序。显示应用程序的PID ,title。并且抓取鼠标相对这个程序的坐标。显示在xlabel,ylabel。
3. 一个按钮能获取图片（图片保存在本地，有一个选择文件的文件地址text和文件选择按钮），并从屏幕上进行匹配这个图片的坐标值。显示在xlabel,ylabel上。




```python

```
